{"index": 0, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/464", "title": "Mem-Wormhole Packet incorrect padding ", "body": "Found these in simulation, correct padding should be \r\nflit_width_mp-((2*cord_width_mp+2*cid_width_mp+len_width_mp+msg_width_mp)%flit_width_mp)\r\n\r\nhttps://github.com/black-parrot/black-parrot/blob/cd949112f849edc1a102fdde71375d156fa55798/bp_me/src/include/v/bp_mem_wormhole.vh#L31\r\nhttps://github.com/black-parrot/black-parrot/blob/cd949112f849edc1a102fdde71375d156fa55798/bp_me/src/include/v/bp_mem_wormhole.vh#L64", "comments": ["Great find! I think the same bug exists for the LCE networks.  It will have come up with the wormhole streamers", "@Songchun-Li keep this in mind when considering the streamers", "Fixed with #602"], "type": "hardware", "design": "black_parrot"}
{"index": 1, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/460", "title": "Vivado synthesis issue with dcache ", "body": "ERROR: [Synth 8-1587] an enum variable may only be assigned to same enum typed variable or one of its values [/home/petrisko/scratch/bsg_fpga/vu37p/black-parrot/bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache.v:989\r\n\r\n@muwyse, I think you have the last changes here", "comments": ["Looks like it just needs a cast to bp_coh_states_e", "Oh, I think you\u2019re right.  I thought it was the replication operator. Usually VCS flags assigning bits to an enum, not sure why it made it to vivado", "I'm not sure either. Neither the VCS or Verilator linter seems to catch it either, although I feel like they have in the past...", "Fixed with: https://github.com/black-parrot/black-parrot/pull/462\r\nClosing."], "type": "hardware", "design": "black_parrot"}
{"index": 2, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/447", "title": "remove write to read forwarding in spec bits", "body": "This change removes write to read forwarding in the CCE spec bits to break a timing loop.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 3, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/443", "title": "Formally handle latency-insensitivity in the fe_cmd queue", "body": "Currently, we provision the fe_cmd queue so that it will not overflow given that the FE dequeues every cycle and we have exactly two entry points (branch resolution and exception/interrupt).  However, this is unintuitive and brittle.\r\n\r\nThere are two solutions that I see:\r\n1) Replay exceptions and not take interrupts when the fe_end is full\r\n2) Do not dispatch instructions when fe_cmd is \"almost full\"\r\n\r\n1 will allow us to have a smaller fe_cmd fifo at the cost of minor complexity.  2 will require a >=3 entry fifo for reasonable performance", "comments": ["Another solution is to use a credit-based fifo, where branches+memory instructions require credits, and committing memory instructions and dequeued fe_cmds return credits", "A credit-based solves the issues mentioned, including more gracefully handling backpressure from the backend, which is needed when considering banked prediction structures.\r\n\r\n- at dispatch, any instruction may generate attaboy / redirect (so don't dispatch if credits empty)\r\n- Similarly, interrupts do not affect credits, but instead are blocked if credits are empty\r\n  - Theoretically, we could still take an interrupt if not empty, but this would 'special case' the credit counting, which sounds dangerous\r\n- branches / memory instructions may generate exceptions\r\n  - decrement credit on dispatch\r\n  - increment credit on dequeue (not commit, because they be flushed)"], "type": "hardware", "design": "black_parrot"}
{"index": 4, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/433", "title": "Poison the Long Pipe Input", "body": "We need to poison the v_i to the long pipe when instruction is not valid due to a branch mispredict.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 5, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/410", "title": "Instruction trace mismatches", "body": "Some benchmarks are showing different instruction traces when changing microarchitectural parameters.  For example, executing rsort on bp_softcore with fe_queue_els_p 8->16 results in the following difference:\r\n\r\n```\r\n[CORE0 FSH] PASS\r\n[CORE0 STATS]\r\n\tclk   :               386819\r\n\tinstr :               370871\r\n\tfe_nop:                    0\r\n\tbe_nop:                    0\r\n\tme_nop:                    0\r\n\tpoison:                13829\r\n\troll  :                 1272\r\n\tmIPC  :                  958\r\n\r\n\r\n[CORE0 FSH] PASS\r\n[CORE0 STATS]\r\n\tclk   :               386762\r\n\tinstr :               369871\r\n\tfe_nop:                    0\r\n\tbe_nop:                    0\r\n\tme_nop:                    0\r\n\tpoison:                13772\r\n\troll  :                 1272\r\n\tmIPC  :                  956\r\n```\r\n\r\nLooking at the instruction traces, there are actually differences in the number of instructions.  Both variants pass cosim, so whatever bad instret logic exists is also affecting that\r\n", "comments": ["Fixed in dev.  Problem was poisoned non-instructions were being spuriously counted", "Yay! Score one for 477 + professor analyzing student reports for oddness.\n\nM\n\nOn Sat, Apr 4, 2020 at 10:06 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Closed #410 <https://github.com/black-parrot/black-parrot/issues/410>.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/black-parrot/issues/410#event-3200944497>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5ABEQUMH6SBKFMMX6ITRLAGWLANCNFSM4LTRQOHQ>\n> .\n>\n"], "type": "hardware", "design": "black_parrot"}
{"index": 6, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/402", "title": "BR + JMP target should be half-word aligned", "body": "https://github.com/black-parrot/black-parrot/blob/master/bp_be/src/v/bp_be_calculator/bp_be_pipe_int.v#L81\r\n\r\nAs per the spec.\r\n\r\n(I believe this will fix #400)", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 7, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/391", "title": "Fix mem noc cid width to x cord width", "body": "https://github.com/black-parrot/black-parrot/blob/2715c73292a848e6f848d11091e18052390be285/bp_top/src/v/bp_tile.v#L543\r\n\r\nCurrently, we have 1 DMC connection per tile column (unlikely to change right now).  The issue with this is if we have x_cord > cid, tiles will alias and the mem responses will go to the wrong tile.  Need to make sure that cid >= x_cord.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 8, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/371", "title": "Minor updates learned from tapeout", "body": "- Fixing x-pessimism in LCE\r\n- Adding host did port to processor\r\n- Changing bp_mem and bp_host to be helpful (less plumbing in testbenches)", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 9, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/345", "title": "Fixing inferred latches", "body": "Inferred latches snuck in for the pad fields of the messages.  Easy fix is setting pad to 0.\r\n\r\nAlso minor CI enhancement where hotfix reuses the cache from dev instead of building its own toolchain.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 10, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/336", "title": "Fixes for verilator cosim build", "body": "", "comments": ["It is bits.  Good call, I'll make it a bit bigger", "Actually, parameter size is [31:0], so we'll run into that before anything else.  I'll leave it for now"], "type": "hardware", "design": "black_parrot"}
{"index": 11, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/320", "title": "Changing interface handshake on cce cmd outputs", "body": "These used to be connected for fifo, so rv& was appropriate.  Now, it's connecting to cache / clint, so r->v has clearer intent.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 12, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/307", "title": "Dispatch packets should be poisoned instead of flushing to be dequeued  from FE queue", "body": "When we take a trap all the instructions read from FE queue should be dequeued, but flushing them zeros their `queue_v` field which causes them not to dequeued from the pipe and making problems when rolling back in the future.\r\nInstead, we keep its `decode` field and just poison it in the calculator.", "comments": ["The problem isn't fully solved yet. I'm still seeing cases where some of the deqs are skipped.", "I\u2019m not sure what new problems you\u2019re seeing, but I think this is a good change overall.\r\nAdded a small patch for clarity", "Update:\r\nThe interrupts are masking the issued packets in the scheduler which causes them to never be dequeued from the FE FIFO. We have to inject the interrupt packets into the FE FIFO from FE to avoid this masking. So basically any issued packet from FE FIFO at scheduler should get to mem3(even if poisoned) so it can be dequeued from the FIFO.", "Hold off on this until interrupt rework. ", "Hi, can we have small test case checked in to our regression? We don\u2019t want\nto have to hunt for this one in the wild to reproduce!\n\nM\n\nOn Fri, Jan 31, 2020 at 9:50 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Hold off on this until interrupt rework.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/pull/307?email_source=notifications&email_token=AEFG5AE4JW6WSZ5IWHPCXJLRASFKFA5CNFSM4KOAPQ22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKP6ZEY#issuecomment-580906131>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AC4FNBTOSFPLRIARYDRASFKFANCNFSM4KOAPQ2Q>\n> .\n>\n", " I think a triggering torture sequence would be:\r\n\r\n\r\nset up mtvec to X\r\n\r\nfor N = 1000\r\nset msip\r\n\r\nCheck I\r\n\r\nX:\r\nLoad Y*i\r\ni+=64\r\nepc+=4\r\nmret \r\n\r\n\r\n> On Feb 1, 2020, at 10:45 AM, taylor-bsg <notifications@github.com> wrote:\r\n> \r\n> \ufeffHi, can we have small test case checked in to our regression? We don\u2019t want\r\n> to have to hunt for this one in the wild to reproduce!\r\n> \r\n> M\r\n> \r\n> On Fri, Jan 31, 2020 at 9:50 PM Dan Petrisko <notifications@github.com>\r\n> wrote:\r\n> \r\n> > Hold off on this until interrupt rework.\r\n> >\r\n> > \u2014\r\n> > You are receiving this because you are subscribed to this thread.\r\n> > Reply to this email directly, view it on GitHub\r\n> > <https://github.com/black-parrot/pre-alpha-release/pull/307?email_source=notifications&email_token=AEFG5AE4JW6WSZ5IWHPCXJLRASFKFA5CNFSM4KOAPQ22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKP6ZEY#issuecomment-580906131>,\r\n> > or unsubscribe\r\n> > <https://github.com/notifications/unsubscribe-auth/AEFG5AC4FNBTOSFPLRIARYDRASFKFANCNFSM4KOAPQ2Q>\r\n> > .\r\n> >\r\n> \u2014\r\n> You are receiving this because your review was requested.\r\n> Reply to this email directly, view it on GitHub, or unsubscribe.\r\n", "Could use the same logic for stress testing exceptions", "@farzamgl we still need a regression test for this, but I've confirmed that interrupts are triggering in RISC-V tests based on this changeset.  I also brought in your mtime_r/w_v change here.  Last, I removed the out-of-band debug mode instructions.  It looks like, with the rolly fifo, injecting into the pipeline is a bad idea, so we'll need another way to enter debug mode (eventually, we're not using that feature for anything right now)", "I think it's not that easy to create a regression for this, because it's really tied to the timing of the program. But we can actually use assertions to check if the fifo packet that's being dequeued has the same pc/instr as the one in mem2.", "That\u2019s an interesting idea. I think that\u2019s a good assertion. I still think we need a directed stress test for interrupts, cache misses and exceptions. It doesn\u2019t have to be super clean, just blast all of those conditions and and see what happens", "@dpetrisko I don't think the correct epc is being loaded when we take an interrupt. I might be wrong, but I think I see that when returning from interrupt we are skipping an instruction."], "type": "hardware", "design": "black_parrot"}
{"index": 13, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/306", "title": "Adding access fault to invalid domain id accesses", "body": "We should prohibit memory accesses to chained chips which may not exist.  Speculative or malicious accesses to these addresses will hang the processor.\r\n\r\nFuture work is to enable foreign domains via the config bus", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 14, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/305", "title": "Preventing host addresses from punching through cached address space", "body": "", "comments": ["This bug causes any cached address matching 0xXXXX_XX1X_XXXX to get routed to I/O routers instead of a CCE.  Our non-Linux benchmarks didn't catch this because they're too small / not located in the \"lucky\" space.\r\n\r\n@taylor-bsg \ud83d\ude4fthe cosim flow.  ", "Oh yeah!!!!!!! Hell yeah! Dromajo in the Haus!\n\nOn Thu, Jan 30, 2020 at 8:52 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> This bug causes any cached address matching 0xXXXX_XX1X_XXXX to get routed\n> to I/O routers instead of a CCE. Our non-Linux benchmarks didn't catch this\n> because they're too small / not located in the \"lucky\" space.\n>\n> @taylor-bsg <https://github.com/taylor-bsg> \ud83d\ude4fthe cosim flow.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/pull/305?email_source=notifications&email_token=AEFG5AAE2B4ZXOBNDXMCIBTRAMVXRA5CNFSM4KN3ZI4KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKMJMNY#issuecomment-580425271>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AADR3YIEYCUDYCIKKTRAMVXRANCNFSM4KN3ZI4A>\n> .\n>\n"], "type": "hardware", "design": "black_parrot"}
{"index": 15, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/267", "title": "Guarantee forward progress on LR/SC", "body": "The following change was proposed on riscv-isa-dev:\r\n\r\n> During the public review period for ratification of the base ISA and standard extensions, the concern was raised that the LR/SC forward-progress guarantee is too onerous to provide in some microarchitectures.  The Board of Directors opted to postpone ratifying the A standard extension until this matter could be studied further.\r\n> \r\n> The memory model task group has since proposed a weaker LR/SC forward-progress guarantee.  It is attached to this email, and we are opening it up for public comment for 45 days.  Note that only the new LR/SC semantics are up for review; the rest of the A extension (all aspects of AMOs, plus the LR/SC instruction encoding) already had a successful public review.  Please provide feedback via the GitHub issue tracker using the Base ISA Ratification tag (https://github.com/riscv/riscv-isa-manual/labels/Base%20ISA%20Ratification), or, for the GitHub-disinclined, you can reply to this email instead.\r\n> \r\n> Informally, the new scheme now only guarantees that _some_ hart will make progress with respect to LR/SC, instead of all harts.  Put another way, only freedom from LR/SC livelock is assured, whereas before, the hardware was also responsible for freedom from starvation.\r\n> \r\n> This new formulation is more in line with other architectures' LR/SC primitives, but is a bit more explicit about what software can expect.  It remains strong enough to implement, among other things, the C++ language standard.\r\n> \r\n> Existing hardware that correctly implements the old scheme remains conformant under this new proposal.\r\n> \r\n> \r\n> Andrew, on behalf of the memory model task group\r\n\r\nProposal: We can guarantee forward progress during LR/SC by ignoring invalidations to that line until the atomic transaction is complete.  We probably should only lock the line after N failures and automatically drop the reservation after M cycles.  Possibly we can reuse the same counter as the livelock LCE counter in dcache.v?\r\n\r\nVerification: A stress test program for multicore contention where each core constantly LR/SCs.  If it reaches the end of the program, forward progress is being made.  Of course, this doesn't formally verify correctness, just efficacy, so further testing may be needed.\r\n\r\nPPA impact: Minimal.  Providing a strong software guarantee is useful though", "comments": ["Just a general note that counters are discouraged if possible.  In general,\nwe want BP to \"fail fast\", because a bug that happens every billion cycles\nis a lot easier to find than one that happens every trillion cycles. =)\n\nM\n\nOn Wed, Oct 2, 2019 at 10:52 AM Dan Petrisko <notifications@github.com>\nwrote:\n\n> The following change was proposed on riscv-isa-dev:\n>\n> During the public review period for ratification of the base ISA and\n> standard extensions, the concern was raised that the LR/SC forward-progress\n> guarantee is too onerous to provide in some microarchitectures. The Board\n> of Directors opted to postpone ratifying the A standard extension until\n> this matter could be studied further.\n>\n> The memory model task group has since proposed a weaker LR/SC\n> forward-progress guarantee. It is attached to this email, and we are\n> opening it up for public comment for 45 days. Note that only the new LR/SC\n> semantics are up for review; the rest of the A extension (all aspects of\n> AMOs, plus the LR/SC instruction encoding) already had a successful public\n> review. Please provide feedback via the GitHub issue tracker using the Base\n> ISA Ratification tag (\n> https://github.com/riscv/riscv-isa-manual/labels/Base%20ISA%20Ratification),\n> or, for the GitHub-disinclined, you can reply to this email instead.\n>\n> Informally, the new scheme now only guarantees that *some* hart will make\n> progress with respect to LR/SC, instead of all harts. Put another way, only\n> freedom from LR/SC livelock is assured, whereas before, the hardware was\n> also responsible for freedom from starvation.\n>\n> This new formulation is more in line with other architectures' LR/SC\n> primitives, but is a bit more explicit about what software can expect. It\n> remains strong enough to implement, among other things, the C++ language\n> standard.\n>\n> Existing hardware that correctly implements the old scheme remains\n> conformant under this new proposal.\n>\n> Andrew, on behalf of the memory model task group\n>\n> Proposal: We can guarantee forward progress during LR/SC by ignoring\n> invalidations to that line until the atomic transaction is complete. We\n> probably should only lock the line after N failures and automatically drop\n> the reservation after M cycles. Possibly we can reuse the same counter as\n> the livelock LCE counter in dcache.v?\n>\n> Verification: A stress test program for multicore contention where each\n> core constantly LR/SCs. If it reaches the end of the program, forward\n> progress is being made. Of course, this doesn't formally verify\n> correctness, just efficacy, so further testing may be needed.\n>\n> PPA impact: Minimal. Providing a strong software guarantee is useful though\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/267?email_source=notifications&email_token=AEFG5AEXY6USIZL4QN6ZUJTQMTNUFA5CNFSM4I4ZOZPKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HPGLHMQ>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AH4NCYSMA2OONGZXRLQMTNUFANCNFSM4I4ZOZPA>\n> .\n>\n", "Makes sense.  Is there an alternative here though?  If we lock the line, we have to unlock it somehow.  That's either based on time or number of blocked requests.  Since we don't have an easy way of measuring backpressure from the LCE, time is simpler.", "Not reading the spec super carefully here, but I would say, something like,\nit auto-unlocks after the commit of 1) an SC, 2) control flow transfer or\n3) 16 instructions.\n\nOn Thu, Oct 3, 2019 at 12:45 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Makes sense. Is there an alternative here though? If we lock the line, we\n> have to unlock it somehow. That's either based on time or number of blocked\n> requests. Since we don't have an easy way of measuring backpressure from\n> the LCE, time is simpler.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/267?email_source=notifications&email_token=AEFG5AA7RKQ5CF5KMCJQ3FLQMZDV7A5CNFSM4I4ZOZPKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEAJLZUY#issuecomment-538098899>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AABSGP7P43ABVPKF4TQMZDV7ANCNFSM4I4ZOZPA>\n> .\n>\n", "Included in latest dev.  Conditions are:\r\n1) Lock timeout starts when cache miss OR LR\r\n2) Lock timeout ends at any hit (includes SC, load or store) or (configurable) N cycles\r\n\r\nThis is compatible with the spec and works for our rollback-based miss system"], "type": "hardware", "design": "black_parrot"}
{"index": 16, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/265", "title": "Making itlb writes unconditional", "body": "while having fetches depend on icache_ready.  Because the fe_mem will conditionally accept the command, it needs to be valid-yumi instead of ready-valid.  This incurs no additional hardware cost, because pc_gen is already helpful, due to the wait state.\r\n\r\nGive this a shot in Linux run before we merge it in, but it's passing regression locally", "comments": ["There might be a regression with beebs, I'm looking into it. I'll hold off merging, but feel free to use this in your Linux branch in the meantime"], "type": "hardware", "design": "black_parrot"}
{"index": 17, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/264", "title": "fe_mem not serving iTLB commands when I$ is busy", "body": "This signal is actually not named properly because the iTLB commands always have to be served in 1 cycle.\r\nhttps://github.com/black-parrot/pre-alpha-release/blob/2532756762959522c8fbba811dd730a905225cec/bp_fe/src/v/bp_fe_mem.v#L139\r\nSo this line actually should be changed to only care about `mem_cmd_ready_i` on fetch commands.\r\nhttps://github.com/black-parrot/pre-alpha-release/blob/2532756762959522c8fbba811dd730a905225cec/bp_fe/src/v/bp_fe_pc_gen.v#L282", "comments": ["on it", "#265 "], "type": "hardware", "design": "black_parrot"}
{"index": 18, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/254", "title": "CSR cmd and response fixes", "body": "Adding immediate extension for CSR cmds. Also fixing pipeline to flush on illegal CSR instructions.  Simplifying flush logic a bit", "comments": ["Traps also include interrupts. I want to get the diagrams up to date and find the invariants for the calculator like we did for the FE, since it looks like some fragile logic chains have built up\n\n> On Sep 12, 2019, at 10:30 PM, Farzam Gilani <notifications@github.com> wrote:\n> \n> \ufeff\n> @farzamgl commented on this pull request.\n> \n> Looks good!\n> Just a small point, isn't the exc_v field identical with the trap_v_o output? Do we need both?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n", "Merging, larger refactor in progress."], "type": "hardware", "design": "black_parrot"}
{"index": 19, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/248", "title": "Remove unnecessary assertion and parameter from be_regfile", "body": "https://github.com/black-parrot/pre-alpha-release/blob/4522fbd2416940ef87a98bf0cc63bb3e8de4eda9/bp_be/src/v/bp_be_calculator/bp_be_regfile.v#L85\r\n\r\nSeems like it is?", "comments": ["good catch", "Rename it bp_be_regfile_bypassing?\r\n", "Really, I should add the bypassing behavior to the RAM...", "Fixed in be_dev.  I left the name the same, because I would like (eventually) to parameterize bypassing support or no, reusing the rest of the module"], "type": "hardware", "design": "black_parrot"}
{"index": 20, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/238", "title": "Trap on misaligned load/stores", "body": "Currently, our D$ only supports aligned loads/stores but will not trap if misaligned requests occur", "comments": ["this capability has been added to the MMU"], "type": "hardware", "design": "black_parrot"}
{"index": 21, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/209", "title": "Mesh router bug breaking Verilator build", "body": "To reproduce: `make build.sc sim.sc dve.sc DUMP=1`\r\n\r\n[5] %Error: bsg_mesh_router.v:155: Assertion failed in testbench.testbench.wrapper.dut.rof1[0].tile.rof3[1].resp_router.bmr.dor_decoder.YX_dor: testbench.testbench.wrapper.dut.rof1[0].tile.rof3[1].resp_router.bmr.dor_decoder.YX_dor: X dim loopback routing00000000\r\n%Error: /home/petrisko/bitbucket/pre-alpha-release/basejump_stl/bsg_noc/bsg_mesh_router.v:155: Verilog $stop\r\n\r\nThis RTL works on VCS, so it's most likely a default parameter-flavored bug. Either way, CI is going to be dead until this is fixed.", "comments": ["Fixed in basejump at some point"], "type": "hardware", "design": "black_parrot"}
{"index": 22, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/189", "title": "Clint write only?", "body": "https://github.com/black-parrot/pre-alpha-release/blob/19cd8defcda72d27de7595a615c4e3c49a01869c/bp_top/src/v/bp_clint.v#L156\r\n\r\nI believe that these registers need to be readable as well per the spec.", "comments": ["Where in the spec do you see this? I don't see anything mentioning memory-mapped reads\r\n\r\n> Platforms provide a real-time counter, exposed as a memory-mapped machine-mode register, mtime. mtime must run at constant frequency, and the platform must provide a mechanism for determining the timebase of mtime.\r\n\r\n> The machine-level MSIP bits are written by accesses to memory- mapped control registers, which are used by remote harts to provide machine-mode interprocessor interrupts.\r\n\r\nMy interpretation was: memory-mapped writes, CSR reads\r\n", "Also, if mtime needs to be writable, then we'll need to modify bsg_cycle_counter to support setting.", "Seems like there should be one read/writable mtime and mtimecmp register\nper core? Maybe it does not make sense to put it on the network?\n\nM\n\nOn Mon, May 27, 2019 at 7:58 AM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Also, if mtime needs to be writable, then we'll need to modify\n> bsg_cycle_counter to support setting.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/189?email_source=notifications&email_token=AEFG5AAPMFJCLPUE2QSYFG3PXPZKDA5CNFSM4HP4DCQKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWKAGLY#issuecomment-496239407>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AC2QPJPHCPR5CSEIM3PXPZKDANCNFSM4HP4DCQA>\n> .\n>\n", "mtime should be shared among all cores. If it's an RTC we only want to have 1 per system. Then, mtimecmps should live near it so we're only sending the timer_irq across the proc instead of the mtime value.\r\n\r\n(oh, and mtime should definitely be readable. whoops, I was mixing up a few requirements).", "If you read the spec carefully, I think they say you need a real time clock\nthat is uniform across the system, but that each core had its own\nread/writeable counter?\n\nM\n\nOn Mon, May 27, 2019 at 10:49 AM Dan Petrisko <notifications@github.com>\nwrote:\n\n> mtime should be shared among all cores. If it's an RTC we only want to\n> have 1 per system. Then, mtimecmps should live near it so we're only\n> sending the timer_irq across the proc instead of the mtime value.\n>\n> (oh, and mtime should definitely be readable. whoops, I was mixing up a\n> few requirements).\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/189?email_source=notifications&email_token=AEFG5AEQTGVZAELERYAGQLTPXQNI3A5CNFSM4HP4DCQKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWKI2IQ#issuecomment-496274722>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AEUD5UKEUFO6465PDLPXQNI3ANCNFSM4HP4DCQA>\n> .\n>\n", "The spec is ambiguous, but Rocket and Ariane both only have 1 mtime register and N mtimecmp registers.  Back when mtime and mtimecmp were CSRs, I believe it was 1 and N as well (although I can't find an old enough spec to prove it).\r\n\r\nOn the one hand, it makes sense that having mtime be global means that you could sync timers between cores more easily. On the other, you don't want cores to clobber each other's timer interrupts, which is why I figured read-only mtime makes sense.", "https://github.com/black-parrot/pre-alpha-release/blob/top_dev_feature_clintpdrework/bp_top/src/v/bp_clint.v\r\n\r\nI made them all (including mtime) MMIO read/write capable for now.  We can take out pathways when we confirm either way", "Great \u2014 seems like they should all be read/write. The RISC-V forum has a\ncouple of code snippets where mtimecmp is read.\n\nM\n\nOn Mon, May 27, 2019 at 2:27 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n>\n> https://github.com/black-parrot/pre-alpha-release/blob/top_dev_feature_clintpdrework/bp_top/src/v/bp_clint.v\n>\n> I made them all (including mtime) MMIO read/write capable for now. We can\n> take out pathways when we confirm either way\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/189?email_source=notifications&email_token=AEFG5AA4DXA7ICLEMOVCO4TPXRG2TA5CNFSM4HP4DCQKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWKRB6Y#issuecomment-496308475>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5ACRSAQJAFWIC53PELTPXRG2TANCNFSM4HP4DCQA>\n> .\n>\n", "Just putting this here for reference.\n\nhttps://groups.google.com/a/groups.riscv.org/forum/m/#!topic/hw-dev/m3VoPhteSgw\n\n\nOn Mon, May 27, 2019 at 8:04 PM Michael Nguyen Taylor <\nmichael.b.taylor@gmail.com> wrote:\n\n> Great \u2014 seems like they should all be read/write. The RISC-V forum has a\n> couple of code snippets where mtimecmp is read.\n>\n> M\n>\n> On Mon, May 27, 2019 at 2:27 PM Dan Petrisko <notifications@github.com>\n> wrote:\n>\n>>\n>> https://github.com/black-parrot/pre-alpha-release/blob/top_dev_feature_clintpdrework/bp_top/src/v/bp_clint.v\n>>\n>> I made them all (including mtime) MMIO read/write capable for now. We can\n>> take out pathways when we confirm either way\n>>\n>> \u2014\n>> You are receiving this because you authored the thread.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/black-parrot/pre-alpha-release/issues/189?email_source=notifications&email_token=AEFG5AA4DXA7ICLEMOVCO4TPXRG2TA5CNFSM4HP4DCQKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWKRB6Y#issuecomment-496308475>,\n>> or mute the thread\n>> <https://github.com/notifications/unsubscribe-auth/AEFG5ACRSAQJAFWIC53PELTPXRG2TANCNFSM4HP4DCQA>\n>> .\n>>\n>\n", "Fixed on off-chip network branch. Will get merged in with those changes"], "type": "hardware", "design": "black_parrot"}
{"index": 23, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/183", "title": "Trap on misaligned uncached loads / stores", "body": "We don't necessarily need to support misaligned loads/stores, but the proposed flow is:\r\n\r\nLCE requests an aligned 64 bytes with a byte mask.\r\nCCE responds with the 64 bytes where only the byte mask is guaranteed to be valid.\r\nLCE is responsible for re-aligning the data and muxing out the valid bytes.", "comments": ["Unless otherwise contraindicated by the ISA, I suggest we treat these as an\nerror for uncached accesses.\n\nM\n\nOn Fri, May 24, 2019 at 5:16 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> We don't necessarily need to support misaligned loads/stores, but the\n> proposed flow is:\n>\n> LCE requests an aligned 64 bytes with a byte mask.\n> CCE responds with the 64 bytes where only the byte mask is guaranteed to\n> be valid.\n> LCE is responsible for re-aligning the data and muxing out the valid bytes.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/183?email_source=notifications&email_token=AEFG5ADR7WC2R2OGACBC543PXCAO3A5CNFSM4HPTMI52YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVZ5EAA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AEA65OXZXAEOSJ7NULPXCAO3ANCNFSM4HPTMI5Q>\n> .\n>\n", "Yep, definitely allowed (through PMAs).", "- [ ] Add misaligned uncached load/store check after the TLB translation\r\n- [ ] Connect this check to the exception pipeline\r\n- [ ] For both I$ and D$", "Closing; long supported"], "type": "hardware", "design": "black_parrot"}
{"index": 24, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/172", "title": "PC gen rework", "body": "This PR is intended to implement the pc_gen rework found at https://docs.google.com/document/d/1r18F7dxunUaRZTh07pzaYvLyV6VwMBJ5X5v9o_PvHIo/edit\r\n\r\nIt is not functional at the moment (hence the WIP DO NOT MERGE). Use it to give feedback and collaborate.", "comments": ["@dpetrisko thank you for providing Anthony feedback, Dan! He's going to be a pro soon enough!", "@zaazad @apducimo can you rebase this branch and fe_dev with dev?", "You have to merge dev->fe_dev and then rebase this branch onto fe_dev\n\n(Because fe_dev is protected)\n\n> On May 18, 2019, at 11:17 AM, Farzam Gilani <notifications@github.com> wrote:\n> \n> @zaazad @apducimo can you rebase this branch and fe_dev with dev?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n", "@farzamgl , could you take a final pass over this? The branch prediction override stuff is still disabled for now, although I think it could potentially work with the BE fix and some RTL changes. But we should punt it for now to derisk for tapeout"], "type": "hardware", "design": "black_parrot"}
{"index": 25, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/155", "title": "Single spurious uncached LR/SC warning", "body": "...should be tracked down. Happens during riscv-tests benchmarks suite", "comments": ["Fixed, assertion needed to depend on reset"], "type": "hardware", "design": "black_parrot"}
{"index": 26, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/116", "title": "CSR machine mode spec adherence", "body": "There is preliminary CSR support in the BE.  However, not all CSRs are fully adherent to spec.  \r\n\r\nFor instance, MTVEC has a field which can be set to support vectored exceptions. Even if we don't support this, we need to prevent writes to these bits (WARL)\r\n\r\nThere are two main asks:\r\n1. Add all machine mode CSRs \r\n2. Add write masks for WARL/WPRI and read masks for WPRI\r\n\r\nThoughts: we should probably list these address and masks in the risc-v defines / package\r\n", "comments": ["Fixed in dev"], "type": "hardware", "design": "black_parrot"}
{"index": 27, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/115", "title": "ITLB passthrough should use VPN, not PPN", "body": "https://github.com/black-parrot/pre-alpha-release/blob/61aba7899652ed70d17dc95c2c8c651ac48aec75/bp_fe/src/v/bp_fe_itlb.v#L44\r\n\r\npaddr should be sign extended version of vaddr\r\n\r\nRelated, the input and output ports vaddr_i and vaddr_miss_o should be vaddr_width, not eaddr_width", "comments": ["Fixed a ways back"], "type": "hardware", "design": "black_parrot"}
{"index": 28, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/460", "title": "Vivado synthesis issue with dcache ", "body": "ERROR: [Synth 8-1587] an enum variable may only be assigned to same enum typed variable or one of its values [/home/petrisko/scratch/bsg_fpga/vu37p/black-parrot/bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache.v:989\r\n\r\n@muwyse, I think you have the last changes here", "comments": ["Looks like it just needs a cast to bp_coh_states_e", "Oh, I think you\u2019re right.  I thought it was the replication operator. Usually VCS flags assigning bits to an enum, not sure why it made it to vivado", "I'm not sure either. Neither the VCS or Verilator linter seems to catch it either, although I feel like they have in the past...", "Fixed with: https://github.com/black-parrot/black-parrot/pull/462\r\nClosing."], "type": "hardware", "design": "black_parrot"}
{"index": 29, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/447", "title": "remove write to read forwarding in spec bits", "body": "This change removes write to read forwarding in the CCE spec bits to break a timing loop.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 30, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/443", "title": "Formally handle latency-insensitivity in the fe_cmd queue", "body": "Currently, we provision the fe_cmd queue so that it will not overflow given that the FE dequeues every cycle and we have exactly two entry points (branch resolution and exception/interrupt).  However, this is unintuitive and brittle.\r\n\r\nThere are two solutions that I see:\r\n1) Replay exceptions and not take interrupts when the fe_end is full\r\n2) Do not dispatch instructions when fe_cmd is \"almost full\"\r\n\r\n1 will allow us to have a smaller fe_cmd fifo at the cost of minor complexity.  2 will require a >=3 entry fifo for reasonable performance", "comments": ["Another solution is to use a credit-based fifo, where branches+memory instructions require credits, and committing memory instructions and dequeued fe_cmds return credits", "A credit-based solves the issues mentioned, including more gracefully handling backpressure from the backend, which is needed when considering banked prediction structures.\r\n\r\n- at dispatch, any instruction may generate attaboy / redirect (so don't dispatch if credits empty)\r\n- Similarly, interrupts do not affect credits, but instead are blocked if credits are empty\r\n  - Theoretically, we could still take an interrupt if not empty, but this would 'special case' the credit counting, which sounds dangerous\r\n- branches / memory instructions may generate exceptions\r\n  - decrement credit on dispatch\r\n  - increment credit on dequeue (not commit, because they be flushed)"], "type": "hardware", "design": "black_parrot"}
{"index": 31, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/433", "title": "Poison the Long Pipe Input", "body": "We need to poison the v_i to the long pipe when instruction is not valid due to a branch mispredict.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 32, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/429", "title": "Fixed sign extension in mul pipe", "body": "", "comments": ["Nice, I actually just found this as well", "Dromajo?\n\nOn Tue, Apr 7, 2020 at 11:59 AM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Merged #429 <https://github.com/black-parrot/black-parrot/pull/429> into\n> dev.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/black-parrot/pull/429#event-3211208835>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AB53JCFKICZNLUIEHDRLNZZNANCNFSM4MDK6W4A>\n> .\n>\n", "> Dromajo?\r\n> [\u2026](#)\r\n> On Tue, Apr 7, 2020 at 11:59 AM Dan Petrisko ***@***.***> wrote: Merged #429 <#429> into dev. \u2014 You are receiving this because you are subscribed to this thread. Reply to this email directly, view it on GitHub <[#429 (comment)](https://github.com/black-parrot/black-parrot/pull/429#event-3211208835)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AEFG5AB53JCFKICZNLUIEHDRLNZZNANCNFSM4MDK6W4A> .\r\n\r\nYes. On vpr.", "nice!\n\nOn Wed, Apr 8, 2020 at 9:15 PM Farzam Gilani <notifications@github.com>\nwrote:\n\n> Dromajo?\n> \u2026 <#m_-6203341118050624808_>\n> On Tue, Apr 7, 2020 at 11:59 AM Dan Petrisko *@*.***> wrote: Merged #429\n> <https://github.com/black-parrot/black-parrot/pull/429> <#429\n> <https://github.com/black-parrot/black-parrot/pull/429>> into dev. \u2014 You\n> are receiving this because you are subscribed to this thread. Reply to this\n> email directly, view it on GitHub <#429 (comment)\n> <https://github.com/black-parrot/black-parrot/pull/429#event-3211208835>>,\n> or unsubscribe\n> https://github.com/notifications/unsubscribe-auth/AEFG5AB53JCFKICZNLUIEHDRLNZZNANCNFSM4MDK6W4A\n> .\n>\n> Yes. On vpr.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/black-parrot/pull/429#issuecomment-611318132>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5ACFNMYAJHGXQWQ4IV3RLVDVFANCNFSM4MDK6W4A>\n> .\n>\n", "On vpr?", "We are trying out some of the spec2000 benchmarks on black-parrot. One of them is a VPR test."], "type": "hardware", "design": "black_parrot"}
{"index": 33, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/410", "title": "Instruction trace mismatches", "body": "Some benchmarks are showing different instruction traces when changing microarchitectural parameters.  For example, executing rsort on bp_softcore with fe_queue_els_p 8->16 results in the following difference:\r\n\r\n```\r\n[CORE0 FSH] PASS\r\n[CORE0 STATS]\r\n\tclk   :               386819\r\n\tinstr :               370871\r\n\tfe_nop:                    0\r\n\tbe_nop:                    0\r\n\tme_nop:                    0\r\n\tpoison:                13829\r\n\troll  :                 1272\r\n\tmIPC  :                  958\r\n\r\n\r\n[CORE0 FSH] PASS\r\n[CORE0 STATS]\r\n\tclk   :               386762\r\n\tinstr :               369871\r\n\tfe_nop:                    0\r\n\tbe_nop:                    0\r\n\tme_nop:                    0\r\n\tpoison:                13772\r\n\troll  :                 1272\r\n\tmIPC  :                  956\r\n```\r\n\r\nLooking at the instruction traces, there are actually differences in the number of instructions.  Both variants pass cosim, so whatever bad instret logic exists is also affecting that\r\n", "comments": ["Fixed in dev.  Problem was poisoned non-instructions were being spuriously counted", "Yay! Score one for 477 + professor analyzing student reports for oddness.\n\nM\n\nOn Sat, Apr 4, 2020 at 10:06 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Closed #410 <https://github.com/black-parrot/black-parrot/issues/410>.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/black-parrot/issues/410#event-3200944497>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5ABEQUMH6SBKFMMX6ITRLAGWLANCNFSM4LTRQOHQ>\n> .\n>\n"], "type": "hardware", "design": "black_parrot"}
{"index": 34, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/402", "title": "BR + JMP target should be half-word aligned", "body": "https://github.com/black-parrot/black-parrot/blob/master/bp_be/src/v/bp_be_calculator/bp_be_pipe_int.v#L81\r\n\r\nAs per the spec.\r\n\r\n(I believe this will fix #400)", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 35, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/391", "title": "Fix mem noc cid width to x cord width", "body": "https://github.com/black-parrot/black-parrot/blob/2715c73292a848e6f848d11091e18052390be285/bp_top/src/v/bp_tile.v#L543\r\n\r\nCurrently, we have 1 DMC connection per tile column (unlikely to change right now).  The issue with this is if we have x_cord > cid, tiles will alias and the mem responses will go to the wrong tile.  Need to make sure that cid >= x_cord.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 36, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/371", "title": "Minor updates learned from tapeout", "body": "- Fixing x-pessimism in LCE\r\n- Adding host did port to processor\r\n- Changing bp_mem and bp_host to be helpful (less plumbing in testbenches)", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 37, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/320", "title": "Changing interface handshake on cce cmd outputs", "body": "These used to be connected for fifo, so rv& was appropriate.  Now, it's connecting to cache / clint, so r->v has clearer intent.", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 38, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/308", "title": "Fixing mtime address and adding mtime write signal", "body": "", "comments": ["Do we need this? Writing mtime is fundamentally broken in the SBI without patching, because of our distributed Clint. I changed the address to indicate this, it is striped by core. \r\n\r\nThe SBI patch needed is to freeze all mtime, write all mtime and unfreeze ", "I believe this will also break all of our current tests ", "I believe the tests are going to be fine, they use the `0x030bff8` address.\r\nWe need to write mtime, if we want to do the checkpointing(the code doesn't write to timer). Also, Linux reads the mtime frequently. \r\nAlso, the sbi_set_timer writes to the mtimecmp, not mtime.\r\nI suggest having the changes until we figure out how to centralize the timer. ", ">We need to write mtime, if we want to do the checkpointing(the code doesn't write to timer).\r\n\r\nGood point, write to mtime for checkpointing is fine.  \r\n\r\n>I believe the tests are going to be fine, they use the 0x030bff8 address\r\n\r\nAre you saying that interrupt-based tests are all currently broken?\r\n\r\n>Linux reads the mtime frequently.\r\n\r\nThe address should come in from the SBI, which we can patch to our address map.  My position is that partial compliance where things almost work is worse than explicit non-compliance.", "> Are you saying that interrupt-based tests are all currently broken?\r\n\r\nKind of broken. The mtime reads in those tests wasn't that critical.\r\n\r\n> The address should come in from the SBI, which we can patch to our address map. My position is that partial compliance where things almost work is worse than explicit non-compliance.\r\n\r\nThe address comes from the device tree parsing in the initial bootloader code. I don't see the point of keeping it at a wrong address though. It's just gonna read zero instead of the timer value. It's still a silent problem. At least now single core boot can work.", ">I don't see the point of keeping it at a wrong address though\r\n>The address comes from the device tree parsing in the initial bootloader code.\r\n\r\nOh yeah definitely not.  I'm saying to change this in software (I guess the mechanism is to modify the device tree?) rather than changing the hardware addresses. ", "But I still don't know what's the point of changing the timer address from the standard one in RTL, tests, and the simulator programs? The functionality is going to stay the same but we're just using the wrong address.", "There\u2019s no \u201cright\u201d or \u201cwrong\u201d one. There is the SiFive choice, which is a unified system-wide mtime at 8ff0. BlackParrot has distributed mtime, which has different functionality and which we can put at wherever we want. Our other clint addresses are also different than the SiFive clint, taking into account both the base and the per-core addresses. \r\n\r\nFirmware which uses the SiFive mtime offset will work for single but fail in multicore for BlackParrot in mysterious ways. Since we\u2019re already patching the memory maps, I don\u2019t see the advantage of partial compliance, only downsides. ", "Merged with #307 "], "type": "hardware", "design": "black_parrot"}
{"index": 39, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/307", "title": "Dispatch packets should be poisoned instead of flushing to be dequeued  from FE queue", "body": "When we take a trap all the instructions read from FE queue should be dequeued, but flushing them zeros their `queue_v` field which causes them not to dequeued from the pipe and making problems when rolling back in the future.\r\nInstead, we keep its `decode` field and just poison it in the calculator.", "comments": ["The problem isn't fully solved yet. I'm still seeing cases where some of the deqs are skipped.", "I\u2019m not sure what new problems you\u2019re seeing, but I think this is a good change overall.\r\nAdded a small patch for clarity", "Update:\r\nThe interrupts are masking the issued packets in the scheduler which causes them to never be dequeued from the FE FIFO. We have to inject the interrupt packets into the FE FIFO from FE to avoid this masking. So basically any issued packet from FE FIFO at scheduler should get to mem3(even if poisoned) so it can be dequeued from the FIFO.", "Hold off on this until interrupt rework. ", "Hi, can we have small test case checked in to our regression? We don\u2019t want\nto have to hunt for this one in the wild to reproduce!\n\nM\n\nOn Fri, Jan 31, 2020 at 9:50 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Hold off on this until interrupt rework.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/pull/307?email_source=notifications&email_token=AEFG5AE4JW6WSZ5IWHPCXJLRASFKFA5CNFSM4KOAPQ22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKP6ZEY#issuecomment-580906131>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AC4FNBTOSFPLRIARYDRASFKFANCNFSM4KOAPQ2Q>\n> .\n>\n", " I think a triggering torture sequence would be:\r\n\r\n\r\nset up mtvec to X\r\n\r\nfor N = 1000\r\nset msip\r\n\r\nCheck I\r\n\r\nX:\r\nLoad Y*i\r\ni+=64\r\nepc+=4\r\nmret \r\n\r\n\r\n> On Feb 1, 2020, at 10:45 AM, taylor-bsg <notifications@github.com> wrote:\r\n> \r\n> \ufeffHi, can we have small test case checked in to our regression? We don\u2019t want\r\n> to have to hunt for this one in the wild to reproduce!\r\n> \r\n> M\r\n> \r\n> On Fri, Jan 31, 2020 at 9:50 PM Dan Petrisko <notifications@github.com>\r\n> wrote:\r\n> \r\n> > Hold off on this until interrupt rework.\r\n> >\r\n> > \u2014\r\n> > You are receiving this because you are subscribed to this thread.\r\n> > Reply to this email directly, view it on GitHub\r\n> > <https://github.com/black-parrot/pre-alpha-release/pull/307?email_source=notifications&email_token=AEFG5AE4JW6WSZ5IWHPCXJLRASFKFA5CNFSM4KOAPQ22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKP6ZEY#issuecomment-580906131>,\r\n> > or unsubscribe\r\n> > <https://github.com/notifications/unsubscribe-auth/AEFG5AC4FNBTOSFPLRIARYDRASFKFANCNFSM4KOAPQ2Q>\r\n> > .\r\n> >\r\n> \u2014\r\n> You are receiving this because your review was requested.\r\n> Reply to this email directly, view it on GitHub, or unsubscribe.\r\n", "Could use the same logic for stress testing exceptions", "@farzamgl we still need a regression test for this, but I've confirmed that interrupts are triggering in RISC-V tests based on this changeset.  I also brought in your mtime_r/w_v change here.  Last, I removed the out-of-band debug mode instructions.  It looks like, with the rolly fifo, injecting into the pipeline is a bad idea, so we'll need another way to enter debug mode (eventually, we're not using that feature for anything right now)", "I think it's not that easy to create a regression for this, because it's really tied to the timing of the program. But we can actually use assertions to check if the fifo packet that's being dequeued has the same pc/instr as the one in mem2.", "That\u2019s an interesting idea. I think that\u2019s a good assertion. I still think we need a directed stress test for interrupts, cache misses and exceptions. It doesn\u2019t have to be super clean, just blast all of those conditions and and see what happens", "@dpetrisko I don't think the correct epc is being loaded when we take an interrupt. I might be wrong, but I think I see that when returning from interrupt we are skipping an instruction."], "type": "hardware", "design": "black_parrot"}
{"index": 40, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/306", "title": "Adding access fault to invalid domain id accesses", "body": "We should prohibit memory accesses to chained chips which may not exist.  Speculative or malicious accesses to these addresses will hang the processor.\r\n\r\nFuture work is to enable foreign domains via the config bus", "comments": [], "type": "hardware", "design": "black_parrot"}
{"index": 41, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/305", "title": "Preventing host addresses from punching through cached address space", "body": "", "comments": ["This bug causes any cached address matching 0xXXXX_XX1X_XXXX to get routed to I/O routers instead of a CCE.  Our non-Linux benchmarks didn't catch this because they're too small / not located in the \"lucky\" space.\r\n\r\n@taylor-bsg \ud83d\ude4fthe cosim flow.  ", "Oh yeah!!!!!!! Hell yeah! Dromajo in the Haus!\n\nOn Thu, Jan 30, 2020 at 8:52 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> This bug causes any cached address matching 0xXXXX_XX1X_XXXX to get routed\n> to I/O routers instead of a CCE. Our non-Linux benchmarks didn't catch this\n> because they're too small / not located in the \"lucky\" space.\n>\n> @taylor-bsg <https://github.com/taylor-bsg> \ud83d\ude4fthe cosim flow.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/pull/305?email_source=notifications&email_token=AEFG5AAE2B4ZXOBNDXMCIBTRAMVXRA5CNFSM4KN3ZI4KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKMJMNY#issuecomment-580425271>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AADR3YIEYCUDYCIKKTRAMVXRANCNFSM4KN3ZI4A>\n> .\n>\n"], "type": "hardware", "design": "black_parrot"}
{"index": 42, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/267", "title": "Guarantee forward progress on LR/SC", "body": "The following change was proposed on riscv-isa-dev:\r\n\r\n> During the public review period for ratification of the base ISA and standard extensions, the concern was raised that the LR/SC forward-progress guarantee is too onerous to provide in some microarchitectures.  The Board of Directors opted to postpone ratifying the A standard extension until this matter could be studied further.\r\n> \r\n> The memory model task group has since proposed a weaker LR/SC forward-progress guarantee.  It is attached to this email, and we are opening it up for public comment for 45 days.  Note that only the new LR/SC semantics are up for review; the rest of the A extension (all aspects of AMOs, plus the LR/SC instruction encoding) already had a successful public review.  Please provide feedback via the GitHub issue tracker using the Base ISA Ratification tag (https://github.com/riscv/riscv-isa-manual/labels/Base%20ISA%20Ratification), or, for the GitHub-disinclined, you can reply to this email instead.\r\n> \r\n> Informally, the new scheme now only guarantees that _some_ hart will make progress with respect to LR/SC, instead of all harts.  Put another way, only freedom from LR/SC livelock is assured, whereas before, the hardware was also responsible for freedom from starvation.\r\n> \r\n> This new formulation is more in line with other architectures' LR/SC primitives, but is a bit more explicit about what software can expect.  It remains strong enough to implement, among other things, the C++ language standard.\r\n> \r\n> Existing hardware that correctly implements the old scheme remains conformant under this new proposal.\r\n> \r\n> \r\n> Andrew, on behalf of the memory model task group\r\n\r\nProposal: We can guarantee forward progress during LR/SC by ignoring invalidations to that line until the atomic transaction is complete.  We probably should only lock the line after N failures and automatically drop the reservation after M cycles.  Possibly we can reuse the same counter as the livelock LCE counter in dcache.v?\r\n\r\nVerification: A stress test program for multicore contention where each core constantly LR/SCs.  If it reaches the end of the program, forward progress is being made.  Of course, this doesn't formally verify correctness, just efficacy, so further testing may be needed.\r\n\r\nPPA impact: Minimal.  Providing a strong software guarantee is useful though", "comments": ["Just a general note that counters are discouraged if possible.  In general,\nwe want BP to \"fail fast\", because a bug that happens every billion cycles\nis a lot easier to find than one that happens every trillion cycles. =)\n\nM\n\nOn Wed, Oct 2, 2019 at 10:52 AM Dan Petrisko <notifications@github.com>\nwrote:\n\n> The following change was proposed on riscv-isa-dev:\n>\n> During the public review period for ratification of the base ISA and\n> standard extensions, the concern was raised that the LR/SC forward-progress\n> guarantee is too onerous to provide in some microarchitectures. The Board\n> of Directors opted to postpone ratifying the A standard extension until\n> this matter could be studied further.\n>\n> The memory model task group has since proposed a weaker LR/SC\n> forward-progress guarantee. It is attached to this email, and we are\n> opening it up for public comment for 45 days. Note that only the new LR/SC\n> semantics are up for review; the rest of the A extension (all aspects of\n> AMOs, plus the LR/SC instruction encoding) already had a successful public\n> review. Please provide feedback via the GitHub issue tracker using the Base\n> ISA Ratification tag (\n> https://github.com/riscv/riscv-isa-manual/labels/Base%20ISA%20Ratification),\n> or, for the GitHub-disinclined, you can reply to this email instead.\n>\n> Informally, the new scheme now only guarantees that *some* hart will make\n> progress with respect to LR/SC, instead of all harts. Put another way, only\n> freedom from LR/SC livelock is assured, whereas before, the hardware was\n> also responsible for freedom from starvation.\n>\n> This new formulation is more in line with other architectures' LR/SC\n> primitives, but is a bit more explicit about what software can expect. It\n> remains strong enough to implement, among other things, the C++ language\n> standard.\n>\n> Existing hardware that correctly implements the old scheme remains\n> conformant under this new proposal.\n>\n> Andrew, on behalf of the memory model task group\n>\n> Proposal: We can guarantee forward progress during LR/SC by ignoring\n> invalidations to that line until the atomic transaction is complete. We\n> probably should only lock the line after N failures and automatically drop\n> the reservation after M cycles. Possibly we can reuse the same counter as\n> the livelock LCE counter in dcache.v?\n>\n> Verification: A stress test program for multicore contention where each\n> core constantly LR/SCs. If it reaches the end of the program, forward\n> progress is being made. Of course, this doesn't formally verify\n> correctness, just efficacy, so further testing may be needed.\n>\n> PPA impact: Minimal. Providing a strong software guarantee is useful though\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/267?email_source=notifications&email_token=AEFG5AEXY6USIZL4QN6ZUJTQMTNUFA5CNFSM4I4ZOZPKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HPGLHMQ>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AH4NCYSMA2OONGZXRLQMTNUFANCNFSM4I4ZOZPA>\n> .\n>\n", "Makes sense.  Is there an alternative here though?  If we lock the line, we have to unlock it somehow.  That's either based on time or number of blocked requests.  Since we don't have an easy way of measuring backpressure from the LCE, time is simpler.", "Not reading the spec super carefully here, but I would say, something like,\nit auto-unlocks after the commit of 1) an SC, 2) control flow transfer or\n3) 16 instructions.\n\nOn Thu, Oct 3, 2019 at 12:45 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> Makes sense. Is there an alternative here though? If we lock the line, we\n> have to unlock it somehow. That's either based on time or number of blocked\n> requests. Since we don't have an easy way of measuring backpressure from\n> the LCE, time is simpler.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/267?email_source=notifications&email_token=AEFG5AA7RKQ5CF5KMCJQ3FLQMZDV7A5CNFSM4I4ZOZPKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEAJLZUY#issuecomment-538098899>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AABSGP7P43ABVPKF4TQMZDV7ANCNFSM4I4ZOZPA>\n> .\n>\n", "Included in latest dev.  Conditions are:\r\n1) Lock timeout starts when cache miss OR LR\r\n2) Lock timeout ends at any hit (includes SC, load or store) or (configurable) N cycles\r\n\r\nThis is compatible with the spec and works for our rollback-based miss system"], "type": "hardware", "design": "black_parrot"}
{"index": 43, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/254", "title": "CSR cmd and response fixes", "body": "Adding immediate extension for CSR cmds. Also fixing pipeline to flush on illegal CSR instructions.  Simplifying flush logic a bit", "comments": ["Traps also include interrupts. I want to get the diagrams up to date and find the invariants for the calculator like we did for the FE, since it looks like some fragile logic chains have built up\n\n> On Sep 12, 2019, at 10:30 PM, Farzam Gilani <notifications@github.com> wrote:\n> \n> \ufeff\n> @farzamgl commented on this pull request.\n> \n> Looks good!\n> Just a small point, isn't the exc_v field identical with the trap_v_o output? Do we need both?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n", "Merging, larger refactor in progress."], "type": "hardware", "design": "black_parrot"}
{"index": 44, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/248", "title": "Remove unnecessary assertion and parameter from be_regfile", "body": "https://github.com/black-parrot/pre-alpha-release/blob/4522fbd2416940ef87a98bf0cc63bb3e8de4eda9/bp_be/src/v/bp_be_calculator/bp_be_regfile.v#L85\r\n\r\nSeems like it is?", "comments": ["good catch", "Rename it bp_be_regfile_bypassing?\r\n", "Really, I should add the bypassing behavior to the RAM...", "Fixed in be_dev.  I left the name the same, because I would like (eventually) to parameterize bypassing support or no, reusing the rest of the module"], "type": "hardware", "design": "black_parrot"}
{"index": 45, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/238", "title": "Trap on misaligned load/stores", "body": "Currently, our D$ only supports aligned loads/stores but will not trap if misaligned requests occur", "comments": ["this capability has been added to the MMU"], "type": "hardware", "design": "black_parrot"}
{"index": 46, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/217", "title": "Synchronous exception priority", "body": "![image](https://user-images.githubusercontent.com/2322266/61071914-3e9d2a80-a3e0-11e9-85b3-3736360a60e3.png)\r\n\r\nSynchronous exception priority has changed in the ratified spec.  I _think_ we're actually safe from this, but still need to check.", "comments": ["How different is the ratified spec from the most recent drafts of the spec\nthat we were looking at?\n\nM\n\nOn Thu, Jul 11, 2019 at 10:34 AM Dan Petrisko <notifications@github.com>\nwrote:\n\n> [image: image]\n> <https://user-images.githubusercontent.com/2322266/61071914-3e9d2a80-a3e0-11e9-85b3-3736360a60e3.png>\n>\n> Synchronous exception priority has changed in the ratified spec. I *think*\n> we're actually safe from this, but still need to check.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/217?email_source=notifications&email_token=AEFG5ABYAPOQB74HFRGLNKLP65VIRA5CNFSM4IBPCBYKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4G6WFCAA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AAVSJGF4OMZJWHXGPLP65VIRANCNFSM4IBPCBYA>\n> .\n>\n", "This is the most significant change IMO.  Mostly just clarifications. Other relevant changes:\r\n\r\n- Added mcountinhibit which prevents performance counters from ticking (adding now)\r\n- Added new PMP semantics (don't have PMP support yet)\r\n- Removed PLIC description (no PLIC yet)\r\n- Removed requirement that xRET clears LR/SC reservation (already how we implemented)\r\n- Specified extended exception/interrupt code space (we don't have an custom E/I)\r\n- Changed semantics for SUM bit in mstatus.  Originally it let S-mode access all U pages, now it can only access U data pages (We hadn't implemented this yet)", "I believe we are compliant, although I'm sure a user will reopen this when I am proven wrong"], "type": "hardware", "design": "black_parrot"}
{"index": 47, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/209", "title": "Mesh router bug breaking Verilator build", "body": "To reproduce: `make build.sc sim.sc dve.sc DUMP=1`\r\n\r\n[5] %Error: bsg_mesh_router.v:155: Assertion failed in testbench.testbench.wrapper.dut.rof1[0].tile.rof3[1].resp_router.bmr.dor_decoder.YX_dor: testbench.testbench.wrapper.dut.rof1[0].tile.rof3[1].resp_router.bmr.dor_decoder.YX_dor: X dim loopback routing00000000\r\n%Error: /home/petrisko/bitbucket/pre-alpha-release/basejump_stl/bsg_noc/bsg_mesh_router.v:155: Verilog $stop\r\n\r\nThis RTL works on VCS, so it's most likely a default parameter-flavored bug. Either way, CI is going to be dead until this is fixed.", "comments": ["Fixed in basejump at some point"], "type": "hardware", "design": "black_parrot"}
{"index": 48, "issue_url": "https://api.github.com/repos/black-parrot/black-parrot/issues/183", "title": "Trap on misaligned uncached loads / stores", "body": "We don't necessarily need to support misaligned loads/stores, but the proposed flow is:\r\n\r\nLCE requests an aligned 64 bytes with a byte mask.\r\nCCE responds with the 64 bytes where only the byte mask is guaranteed to be valid.\r\nLCE is responsible for re-aligning the data and muxing out the valid bytes.", "comments": ["Unless otherwise contraindicated by the ISA, I suggest we treat these as an\nerror for uncached accesses.\n\nM\n\nOn Fri, May 24, 2019 at 5:16 PM Dan Petrisko <notifications@github.com>\nwrote:\n\n> We don't necessarily need to support misaligned loads/stores, but the\n> proposed flow is:\n>\n> LCE requests an aligned 64 bytes with a byte mask.\n> CCE responds with the 64 bytes where only the byte mask is guaranteed to\n> be valid.\n> LCE is responsible for re-aligning the data and muxing out the valid bytes.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/black-parrot/pre-alpha-release/issues/183?email_source=notifications&email_token=AEFG5ADR7WC2R2OGACBC543PXCAO3A5CNFSM4HPTMI52YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVZ5EAA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AEFG5AEA65OXZXAEOSJ7NULPXCAO3ANCNFSM4HPTMI5Q>\n> .\n>\n", "Yep, definitely allowed (through PMAs).", "- [ ] Add misaligned uncached load/store check after the TLB translation\r\n- [ ] Connect this check to the exception pipeline\r\n- [ ] For both I$ and D$", "Closing; long supported"], "type": "hardware", "design": "black_parrot"}
{"index": 49, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/564", "title": "Floating point rounding mode is not working correctly", "body": "<!-- choose all that apply -->\r\n**Type of issue**: bug report \r\n\r\n<!-- if the issue is NOT a question, fill out the following sections -->\r\n\r\n<!-- choose one -->\r\n**Impact**: unknown\r\n\r\n<!-- choose one -->\r\n**Development Phase**: request \r\n\r\n**Other information**\r\nI am running a program with float and double instructions and I am observing mismatches in write-back values of these instructions when comparing my RTL simulation and Spike.\r\n\r\n```\r\nfsqrt.d fa3, fa3 \r\nInstruction in hex: 0x5a06c6d3\r\n```\r\nValue of the input argument to the instruction is\r\n```\r\n0x41e2e80040000000 = 2537554432.0\r\nsqrt(2537554432.0) = 50374.1444790876820703394273903...\r\n```\r\nAccording to the RISC-V spec and the decoded instruction, rounding mode of this instruction is **Round to Nearest, ties to Max Magnitude (RMM).** I am getting the following write-back values from Spike and RTL sim.\r\n\r\nFollowing are the results I am getting from Spike and RTL simulation of BOOM (emulator). \r\n\r\nFor further details about the conversion refer: https://stackoverflow.com/a/69366740/15497085\r\n```\r\nSpike wdata   = 0x40e898c49f929b92     50374.144479087 685 (in decimal)\r\nSpike         =  0x1.898c49f929b92p+15 50374.144479087 684886               +0028\r\nsqrt(2537554432.0)                     50374.144479087 6820703394273903...\r\nRTL sim       =  0x1.898c49f929b91p+15 50374.144479087 677610               -0044\r\nRTL sim wdata = 0x40e898c49f929b91     50374.144479087 680 (in decimal)\r\n```\r\n\r\n**I am getting the same value that Spike is giving with dromajo and rocket-chip emulator as well.**\r\n\r\n\r\n<!-- if the current behavior is a bug, please provide the following steps to reproduce the problem -->\r\n\r\n**What is the current behavior?**\r\n`0x40e898c49f929b91 `\r\n\r\n**What is the expected behavior?**\r\n`0x40e898c49f929b92`\r\n\r\n**Please tell us about your environment:**\r\n    - version: e252e797c21aa3bf860cb9d67c6009ef00c5916f\r\n    - os: `Linux 3.10.0-1160.36.2.el7.x86_64 #1 SMP x86_64 x86_64 x86_64 GNU/Linux`\r\n    - build environment: https://github.com/ucb-bar/chipyard/commit/b5d013190d637e634113cb5179f8c8885df1945a\r\n\r\n**What is the use case for changing the behavior?**\r\nImplementing correct floating-point rounding behavior.", "comments": ["This is only partially surprising to me. I never got around to closely verifying the FP RM behavior. I'm not surprised there's a bug here."], "type": "hardware", "design": "riscv_boom"}
{"index": 50, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/553", "title": "Unsafe mechanism in LSU and speculative loads", "body": "<!-- choose all that apply -->\r\n**Type of issue**: question\r\n\r\nI am currently experimenting with early retirement for ROB (essentially retiring instructions when they are no longer speculative, i.e. ``!rob_unsafe``, rather than waiting for them to complete execution, i.e. ``!rob_bsy``). This involves using the unsafe mechanism in LSU to mark loads and stores in the ROB as safe. According to my understanding, they are marked safe when they are resolved in the LSU, i.e. ``paddr`` known. However, this mechanism apparently misses dependent loads (loads to the same addresses), possibly causing a ``MINI_EXCEPTION_MEM_ORDERING`` exception to be thrown on the already retired load. The following sequence of events can result in that happening.\r\n\r\nLoads A (older) and B (younger) have the same address.\r\n1. Resolved load B (``fired_load_incoming``) requests its data from ``dmem``. Load A is unresolved. Hence, load B's request is not squashed and completes successfully, i.e. ``succeeded``\r\n2. Load B later (``fired_load_retry``) becomes resolved, but receives a ``nack`` from ``dmem``. After this point, loads A and B retire from the ROB.\r\n3. Loads A and B are later marked ``observed``.\r\n4. Load B later then (``fired_load_wakeup``) discovers an ordering failure (since load B executed before load A). Hence, load B (and the instructions after it) has to be flushed and replayed. However, as mentioned, A and B have already retired from the ROB.\r\n\r\nQuestion: Is there a workaround for this corner case(?) or the unsafe mechanism in the LSU has to be switched off entirely for loads?", "comments": ["Oh yeah this was an annoying corner case to deal with. I don't think I ever had a satisfactory solution, besides, as you say, disabling the unsafe mechanism for loads."], "type": "hardware", "design": "riscv_boom"}
{"index": 51, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/459", "title": "source field in ProbeAckData", "body": "<!-- choose all that apply -->\r\n**Type of issue**: bug report \r\n\r\n<!-- if the issue is NOT a question, fill out the following sections -->\r\n\r\n<!-- choose one -->\r\n**Impact**: unknown\r\n\r\nWhen RocketTile with Boom core receives PROBE_REQUEST message through tilelink b ports, it responds with with PROBE_ACK (_DATA) messages.\r\nThe source fields of PROBE_REQUEST message and PROBE_ACK message should be same as in tilelink-spec-1.8.0, however they have different value in the simulation.\r\n\r\nCould you check this behavior?\r\n\r\nHere's the waveform and you can see those messages (tl_b, tl_c) near the last.\r\n\r\n[waveform.zip](https://github.com/riscv-boom/riscv-boom/files/4550164/waveform.zip)\r\n", "comments": ["Thanks for finding this. Can you see if this fix works for you? The fix should be to change this line\r\nhttps://github.com/riscv-boom/riscv-boom/blob/e81d8ccbdb2906fc165fedaed8fb264d9f824037/src/main/scala/lsu/dcache.scala#L66\r\n\r\nto\r\n```\r\nfromSource = req.source,\r\n```\r\n\r\nIn the original DCache design (from Rocket), voluntary writebacks are always executed before a refill request, so the source id for the `Release` (voluntary eviction) message is reused from the source id of the MSHR which will handle the `Refill` once the `Release` is complete. In the new BOOM DCache, to support parallel `Refill` and `Release`. the `WritebackUnit` is allocated its own source id to use.\r\nHowever, the `WritebackUnit` should not use this source-id for `ProbeAck`, as you describe. Instead it should use the source-id of the `Probe`", "I'm very curious why this didn't cause any issues with my testing... I've tested this with TLMonitors, which *should* verify TileLink conformance.\r\n\r\nBOOM also runs large programs successfully with this bug present, so the other components in the memory hierarchy must be tolerant to this bug?", "Yes, your patch fixes the bug.\r\nNow they have same source id.\r\n\r\nMaybe other components in the hierarchy does not check the source id as seriously, but I couldn't test with the other components because I'm only testing on RocketTile which contains BoomCore.", "Broadcaster doesn't know each cache's each sourceID's client function in the sourceID range of each cache, so it simply send probe message with each cache\u2018s first sourceID. But in Boom's dcache ,the first sourceID is for mshr, while the last sourceID in sourceID range is for probeack(data) message. MSHR in Boom don't use B,C channel, so we can use the MSHR's sourceID for probe and probeack(data) message ? ", "According to TileLink spec the Writeback response to a Probe must carry the same sourceId that the Probe was originally sent with. In BOOM the writeback unit did not respect this, which caused some TileLink compliance assertions to fire. The patch I posted above fixes the issue."], "type": "hardware", "design": "riscv_boom"}
{"index": 52, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/417", "title": "AMO Exceptions scause Error", "body": "<!-- choose all that apply -->\r\n**Type of issue**: bug report\r\n\r\n<!-- if the issue is NOT a question, fill out the following sections -->\r\n\r\n<!-- choose one -->\r\n**Impact**: new rtl\r\n\r\n<!-- choose one -->\r\n**Development Phase**: request\r\n\r\n**Other information**\r\n\r\nCurrently when running the `rv64ua-v-lrsc` asm test, the `scause` value differs from Dromajo when doing an `amoadd.w`. On further inspection we don't adhere to the specification for the AMO exceptions. Here is the priv. spec:\r\n\r\n![image](https://user-images.githubusercontent.com/8823803/69998326-e68bcf80-150a-11ea-9111-8911cdcb7b12.png)\r\n\r\nAll AMO exceptions should be mapped to a ST exception. However, LR/SC exceptions should not be affected by this.\r\n\r\n**What is the current behavior?**\r\n\r\nAn `amoadd.w` page fault returns an LD page fault exception.\r\n\r\n**What is the expected behavior?**\r\n\r\nAn `amoadd.w` page fault returns an ST page fault exception AKA an AMO page fault exception. This also applies to all other AMO instructions.\r\n\r\n**Please tell us about your environment:**\r\n\r\nVersion: 397992d535d14d38658e8503a5ededa3430bb352\r\n\r\n**What is the use case for changing the behavior?**\r\n\r\nTo adhere to the RISCV specification.\r\n", "comments": [], "type": "hardware", "design": "riscv_boom"}
{"index": 53, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/332", "title": "Long Latency Writeback Port Fix", "body": "<!-- choose one -->\r\n**Type of change**: bug fix\r\n\r\n<!-- choose one -->\r\n**Impact**: rtl refactoring\r\n\r\n<!-- choose one -->\r\n**Development Phase**: implementation\r\n\r\n**Release Notes**\r\nDon't let the long latency port do a writeback unless its uop has the right destination type. Currently only affects RoCC.", "comments": [], "type": "hardware", "design": "riscv_boom"}
{"index": 54, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/331", "title": "RoCC writeback fix", "body": "<!-- choose one -->\r\n**Type of change**: bug fix\r\n\r\n<!-- choose one -->\r\n**Impact**: rtl refactoring\r\n\r\n<!-- choose one -->\r\n**Development Phase**: implementation\r\n\r\n**Release Notes**\r\nThe RoCC writeback request logic wasn't considering whether it's uop required a writeback.\r\n", "comments": ["This is intentional. This is how it unbusys the rob. "], "type": "hardware", "design": "riscv_boom"}
{"index": 55, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/324", "title": "[rocc] Fix RoCC interrupts/exceptions/decode/writeback", "body": "**Related issue**: <!-- if applicable -->\r\n\r\n<!-- choose one -->\r\n**Type of change**: bug fix \r\n<!-- choose one -->\r\n**Impact**:  new rtl\r\n\r\n<!-- choose one -->\r\n**Development Phase**: implementation\r\n\r\n**Release Notes**\r\n<!-- Text from here to the end of the body will be considered for inclusion in the release notes for the version containing this pull request. -->\r\n", "comments": [], "type": "hardware", "design": "riscv_boom"}
{"index": 56, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/289", "title": "ROB Head & Tail Fix", "body": "Fixed behavior of ROB head and tail lower order bits for pipeline widths > 3.", "comments": ["Let's delay merging these until the stq issue is resolved."], "type": "hardware", "design": "riscv_boom"}
{"index": 57, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/178", "title": "Recovery after executing 'x", "body": "MegaBoomConfig\r\n\r\nAssertion failed: Pipeline has hung.\r\n    at core.scala:1143 assert (!(idle_cycles.value(13)), \"Pipeline has hung.\")\r\n\r\nThis happens as the processor goes to execution from the address 0x10022f88, in which the 'x.\r\n\r\nI have the code:\r\n    10001b5c:\t64813083          \tld\tra,1608(sp)\r\n    10001b60:\t65010113          \taddi\tsp,sp,1616\r\n    10001b64:\t00008067          \tret\r\n\r\nsp = 100222f0\r\nWhen executed, it becomes ra = sp + 1608 + 1616 = 0x10022f88.\r\n\r\nThis happens because a false bypass happens in iregister_read:\r\nIn iregister_read, I see the following:\r\n![screenshot from 2019-02-01 17-01-43](https://user-images.githubusercontent.com/30556064/52121940-265ffd00-2643-11e9-863c-ce3dc2a8c287.png)\r\n\r\nThis bypass goes from alu to csr_exe_unit:\r\n![screenshot from 2019-02-01 17-06-09](https://user-images.githubusercontent.com/30556064/52122131-b736d880-2643-11e9-95df-99cd32e0f05d.png)\r\n\r\nIt seems to me that this bypass should not be.\r\nI will continue to study the problem. Does anyone have any ideas?", "comments": ["Is the test small and reproducible using the default Boom flow? If so, maybe we can take a look.\r\n\r\nHowever, if you have a fsdb file of the failure occurring, then you have everything needed to diagnosis this I think.\r\n\r\nRegarding the bypass logic, the only thing that would prevent the `add` from the future bypassing to the `load` behind him is that the `add` should be allocated a new, different physical register specifier (`pdst`). I would check to see what the `pdst` of the bypassed `add` is and compare it to the `pop1` (operand) of the `load`. I assume they will be the same, if this erroneous bypass is occurring.\r\n\r\nThen the next step is to figure out who has the wrong physical specifier and why. Did they enter the issue window with the wrong specifier? Did they leave rename with the wrong specifier? Was there a stall in rename? Did the load and add leave rename together? Was there a mispredict and reset? \r\n", "The problem was that I simulated without RANDOMIZE_MEM_INIT. Because of the false predictions, boom switched to executing the 'x instruction, which led to the breakdown of FetchController and \"Pipeline has hung.\"\r\n\r\nHere is a small test that reproduces this situation:\r\n```\r\n  li   a0, 7\r\nwait:\r\n  addi a0, a0, -1\r\n  bne  a0, x0, wait\r\n  beq  a0, x0, after_wait\r\nkill_boom:\r\n  j    good + 0xfff00 # (at this address must be 'x)\r\nafter_wait:\r\n  la   ra, good\r\n  ret\r\n\r\ngood:\r\n  la   t0, .tohost\r\n  li   t1, 1\r\n  sw   t1, 0(t0)\r\n  j    good\r\n```\r\n\r\nI have a question, should a boom recover from an attempt to execute an 'x instruction as a result of false prediction? I can try to fix it, but I'm afraid of increasing the critical path.", "Do you know which module in fetch was the source of the breakdown? I am aware that the fetchbuffer leads to x propagation errors. ", "I mentioned the fetchbuffer issue here: https://github.com/riscv-boom/riscv-boom/pull/141#discussion_r244556464", "Hi @pentin-as , has this already been resolved? If so, I will go ahead and close this issue."], "type": "hardware", "design": "riscv_boom"}
{"index": 58, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/153", "title": "Bug with 4-cycle loaduse", "body": "There's a bug with 4-cycle load-use. Here are two runs in which it appeared. The first is a dual-core config booting buildroot Linux. The second is a single-core config booting Fedora.\r\n\r\n```\r\nid: 1190, module: IssueSlot_4, path: FireBoomNoNIC.tile_1.core.issue_units_0.slots_3]\r\nAssertion failed\r\n    at issue_slot.scala:214 assert (!slot_p1_poisoned)\r\n    at cycle: 2142042185\r\n```\r\n```\r\n[id: 601, module: IssueSlot_4, path: FireBoomNoNIC.tile.core.issue_units_0.slots_2]\r\nAssertion failed\r\n    at issue_slot.scala:216 assert (!slot_p1_poisoned)\r\n at cycle: 195769823414\r\n```\r\n", "comments": [], "type": "hardware", "design": "riscv_boom"}
{"index": 59, "issue_url": "https://api.github.com/repos/riscv-boom/riscv-boom/issues/148", "title": "Fix RAS ", "body": "Currently the RAS is left disconnected, yet some of the logic is synthesized when nRAS > 0.\r\nhttps://github.com/riscv-boom/riscv-boom/blob/f35cc753a9cc5b15402cf7336f8a98912c6533a3/src/main/scala/bpu/bpd-pipeline.scala#L151-L152\r\n\r\nThis causes the vestigial RAS to inject false predictions to 0x0 in S1 of BTB, sometimes overriding the valid BTB predictions. In dhrystone MediumBoomConfig with a RAS takes 10% more cycles than SmallBoomConfig with no RAS. Preferably the RAS should be fixed and connected.\r\n\r\nSide request: Can we also refactor the RAS to be a module, so that the internal registers and io is available to inspect in waveforms? \r\n\r\n", "comments": ["Is the performance bug mentioned above caused by RAS underflow? I just noticed that medium boom uses only 8 entries of RAS and turns off EmptyCheck. Because calling stack of dhrystone is deep, RAS underflow can degrade perfromance significantly.\r\nMy result shows that for small boom with 8-entry RAS, EmptyCheck boosts IPC for about 2%.", "We found that for programs with a very shallow call stack, the RAS would mispredict more frequently than expected. There is some issue with the RAS update logic which is polluting it. "], "type": "hardware", "design": "riscv_boom"}
{"index": 60, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1903", "title": "Exclude unread module from toggle coverage", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThis module is instantiated to tie the unconnected nets. They are not functional and can be excluded from code coverage.", "comments": ["@ASintzoff @AEzzejjari @AnouarZajni ", "@JeanRochCoulon which module specifically ?", "The module name is \"unread\". \r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/56552370/d45984ec-f9f3-41c6-a24e-754056cabc06)\r\n", "Done by #1907 "], "type": "hardware", "design": "default_riscv"}
{"index": 61, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1902", "title": "Condition coverage limitation", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nIn the frontend.sv, the line 373 does not appear in the condition coverage report. To me, this is a condition coverage case. I am concerned because I think it hides an implementation bug. How to make it appear in the coverage report?\r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/56552370/858e6fb0-b2d8-414f-8810-054419f9585e)\r\n\r\n@AyoubJalali @ASintzoff @AEzzejjari \r\n", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 62, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1866", "title": "[BUG] sfence.vma instruction", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nHello,\r\nAs the sfence.vma is a supervisor instruction, it should be treated as an illegal instruction, if the supervisor mode isn't supported, and this is the case with the **CV32A60X** , but it doesn't raised an illegal exception.\r\n\r\nso to reproduce the Bug you only need to create a test with a sfence.vma", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 63, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1844", "title": "[BUG] mcountinhibit CSR", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nAs the CV32A60X does not support _**mcountinhibit**_ , that's means we should only read-zero as the RISCV spec mentioned \r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/99381f00-18c8-4b49-8b68-09b77429c766)\r\n\r\nbut the CV32A60X read non-zero values as you see in the example : \r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/746cb2a9-bb52-4bdc-be12-ad5d7b27c2b5)\r\n\r\n", "comments": ["> As the CV32A60X does not support _**mcountinhibit**_ , that's means we should only read-zero as the RISCV spec mentioned\r\n\r\nThe spec does not say that we should read zero. As the CSR is not implemented, there will be exceptions on read/write accesses."], "type": "hardware", "design": "default_riscv"}
{"index": 64, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1843", "title": "[BUG] Unsupported CSRs", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello,\r\nAs the CV32A60X does not support User mode, so the Following CSRs should not exist : MENVCFG, MENVCFGH, MCOUNTEREN, in another term the CV32A60X should raise an exception when trying to write or read from these CSRs.\r\n\r\nAs Volume II: RISC-V Privileged Architectures V20211203 : ### **If U-mode is not supported, then registers menvcfg and menvcfgh do not exist.**\r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/bc66b8c7-eae2-4a66-82a3-5ce24b0ddf71)\r\n\r\nalso \r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/26636c96-11d2-4b03-9af3-ed020e8237dc)\r\n\r\nTo reproduce the Bug, you only need a test trying to read or write to one of these CSRs.", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 65, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1823", "title": "[BUG] *.dcp file does not exist for the DDR memory interface", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nI have an error while generating the FPGA bitstream:\r\n```bash\r\nmake fpga\r\n```\r\nGives me this error related to the MIG which should generate the DDR controller:\r\n```bash\r\n# set file_obj [get_files -of_objects [get_filesets sources_1] [list \"*$file\" \"$registers\"]]\r\n# set_property -dict { file_type {Verilog Header} is_global_include 1} -objects $file_obj\r\n# update_compile_order -fileset sources_1\r\n# add_files -fileset constrs_1 -norecurse constraints/$project.xdc\r\n# synth_design -rtl -name rtl_1\r\nCommand: synth_design -rtl -name rtl_1\r\nStarting synth_design\r\nUsing part: xc7k325tffg900-2\r\nTop: ariane_xilinx\r\nINFO: [Device 21-403] Loading part xc7k325tffg900-2\r\n1 Infos, 0 Warnings, 0 Critical Warnings and 1 Errors encountered.\r\nsynth_design failed\r\nERROR: [Runs 36-527] DCP does not exist: /home/pascal/Documents/riscv-iommu-demo/cva6/corev_apu/fpga/xilinx/xlnx_mig_7_ddr3/xlnx_mig_7_ddr3.gen/sources_1/ip/xlnx_mig_7_ddr3/xlnx_mig_7_ddr3.dcp\r\n```\r\n\r\nThe error is similar to https://github.com/openhwgroup/cva6/issues/824 but the solution given there didn't work (open `ariane.xpr` and generate output products for the DDR controller)", "comments": ["Nevermind, it seemed to be an issue with my memory."], "type": "hardware", "design": "default_riscv"}
{"index": 66, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1807", "title": "Add the condition for updating the tlb only after a miss is incurred", "body": "Problem Statement:\r\n\r\nIn the TLB module of the MMU_sv32 unit during the update and flush mode, if the flush signal is high, the TLB is flushed according to the SFENCE.VMA command. However, in the event that the flush signal is not enabled the value in the TLB module is updated regardless of whether there was a hit or a miss in the TLB. If the updated value from the shared TLB is valid one of the entries in the TLB is updated with this value.\r\n\r\nProposed Solution:\r\n\r\nDuring the update phase while checking that the updated value is valid or not it should also be checked that the TLB was missed and only in the case that the TLB was missed should the SHARED_TLB be accessed and an update value received from it.", "comments": [":heavy_check_mark: successful run, report available [here](https://riscv-ci.pages.thales-invia.fr/dashboard/dashboard_cva6_1807.html).", "Thanks @HudaSajjad for this PR.  @AngelaGonzalezMarino Can I ask you to approve it ?", "Sure, I will look at it and include it in the merged MMU", "> Sure, I will look at it and include it in the merged MMU\r\n\r\n@AngelaGonzalezMarino you can look so that we can merge this separately, and MMU unifying work can continue alongside. Thanks.\r\n", "What is the update on this? @AngelaGonzalezMarino @JeanRochCoulon ", "Hi, it seems OK to me. I have tried with sv32 and sv39 configurations, both work OK (work means that Yocto boots on both of them). I don't see any performance gain either (booting time is the same). Is there a specific test I should do to see some change or benefit?\r\n\r\nActually, I think in a way the behaviour was already the same. Without a miss, the shared TLB does not give a valid update, (itlb_req_q or dtlb_req_q need to be set in order to output a 1 in the valid flag of the itlb or dtlb update). Therefore, the TLB does not update if there is no miss, because there is no valid. Have you seen a case where this is different?", "This is already integrated in the unified MMU https://github.com/openhwgroup/cva6/pull/1851", "Closing this one, since @AngelaGonzalezMarino included this change in https://github.com/openhwgroup/cva6/pull/1851"], "type": "hardware", "design": "default_riscv"}
{"index": 67, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1785", "title": "[BUG] Allow one outstanding killed miss", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\n@colluca has sublitted a PR to fix the following performance bug #1497. As the PR has not been merged. This github issue backup the problem.\r\n\r\nThe I$ can receive a speculative request from the instruction fetch unit (e.g. upon a branch). If this instruction is not in the cache we will incur a miss and a refill request will be issued to the memory. If, when the branch is resolved, the speculated instruction is killed, the refill request will be killed (i.e. the speculated instruction will never be loaded into the cache). Despite being killed, the I$ still waits on the request from memory to be back, stalling all other operation. This implies that even with a hot cache, we can still experience cache miss stalls on speculated instructions which will never enter the cache, and hence the cache will never truely be \"hot\" (in this sense, speculated instructions should be considered part of the working set).\r\n\r\nThis PR attempts to improve performance in this condition by handling up to one killed refill request asynchronously. A speculated miss will only induce a stall if another miss occurs before the killed refill returns from memory.", "comments": ["Miek, I cannot assign @colluca to this issue, can you include him to the  CVA6 project ?"], "type": "hardware", "design": "default_riscv"}
{"index": 68, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1778", "title": "When running the program, the output of the Linux terminal suddenly gets stuck.", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nWhen I was running my own C++program, the output printed through the printf() function suddenly froze on the serial terminal. And I cannot make any input through the keyboard in the terminal. But through Vivado's Logic Analyzer, it can be seen that my program has actually completed the entire operation normally. I have tried different terminal tools and the phenomenon is the same. So I think it may be a hardware issue.\r\n\r\nThe output of the serial terminal gets stuck in the area shown in the picture, sometimes also getting stuck in \"wrbuf11\" and \"wrbuf13\". At that location, I configured some custom registers through the AXI bus. Did this operation affect the serial part? Has anyone encountered a similar situation as me?\r\n\r\nAny help or clarification would be much appreciated. Thanks!\r\n\r\n![3](https://github.com/openhwgroup/cva6/assets/78201017/99ef7348-25ef-47d1-a312-cdf47873fcee)\r\n![4](https://github.com/openhwgroup/cva6/assets/78201017/cec488f9-a8f5-4387-b64d-273068c260e2)\r\n", "comments": ["@jquevremont     I labeled this PR as \"Component:SW\" but I do not know who to assign. I set your name, sorry for the bad gift. We should discuss it during cva6 meeting. ", "@chenqian13, are you using https://github.com/openhwgroup/meta-cva6-yocto on Genesys 2 board?", "Hi! @jquevremont \r\nNo, I'm using https://github.com/openhwgroup/cva6-sdk on xcku5p board. \r\nI added an axi master and axi slave in the design. I added the axi-slave device information (as shown in the figure) and changed the CPU clock-frequency and UART clock-frequency (both equal to CLK_OUT1=100MHZ) in \"cv64a6_genesysII.dts\" under \"cva6-sdk/uboot/arch/riscv/dts/\", and then remade the Linux system. In addition, I did the same thing for \"cv64a6. dts\" under \"FPGA/src/bootrom\" and regenerated the bootrom_ 64.sv.\r\nShould I add my master device information in the dts files?\r\n\r\nWhat's the difference between https://github.com/openhwgroup/cva6-sdk and https://github.com/openhwgroup/meta-cva6-yocto ? Should I use https://github.com/openhwgroup/meta-cva6-yocto to make Linux\uff1f \r\n\r\n![dts1](https://github.com/openhwgroup/cva6/assets/78201017/b512b197-e15a-4692-a9ae-4531180786c0)\r\n\r\n\r\n", "cva6-dsk is based on BuildRoot. meta-cva6-yocto is based on Yocto.\r\nMay I suggest that you start your Linux system on a Genesys 2 board to get it up and running and add the AXI peripherals. This would be more incremental, starting from a known working configuration.\r\nWe have not worked on the xcku5p board and can't provide advice on it. Genesys 2 is the \"default\" OpenHW FPGA board.", "@jquevremont OK, thank you for your quick reply\uff01\r\n\r\nI would greatly appreciate it if anyone else could continue to offer help or suggestions!", "Hi! @jquevremont \r\nI followed the README in the \"meta-cva6-yocto\" repository and finally generated the content shown in the figure.\r\nThen I executed the following command: gunzip -c build/tmp-glibc/deploy/images/cv64a6-genesys2/core-image-minimal-cv64a6-genesys2.wic.gz | sudo dd of=/dev/sd$ bs=1M iflag=fullblock oflag=direct conv=fsync status=progress\r\nBut I was unable to successfully start the system. \r\nI want to know what the partition requirements for the SD card are. Also, I would like to know if there are any other files that need to be placed in the SD card besides the files in the command above.\r\n\r\n![1](https://github.com/openhwgroup/cva6/assets/78201017/6937b4e3-c051-48ee-995e-58822874d5fc)\r\n\r\n"], "type": "hardware", "design": "default_riscv"}
{"index": 69, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1756", "title": "[BUG] MSTATUS MPP incorrect read value after write ", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nWhen CVA6 is in embedded configuration (Only M mode) MPP field has just one possible value `0b11`. As the MPP field is WARL, it should read a legal value after a write which it can only be `0b11` in the MPP field.\r\n\r\n### Environment: \r\nHash: cd0ade199cffcf42f145b381988f3303405ec940\r\n\r\n### How to Reproduce:\r\n``` bash\r\nsource ./verif/sim/setup-env.sh\r\npython3 cva6.py --testlist=../tests/testlist_csr_embedded.yaml --test csr_test --iss_yaml cva6.yaml --target cv32a6_embedded --iss=vcs-testharness\r\n```\r\n\r\n### Evidence:\r\nIn the `output/$(date)/vcs-testharness_sim/csr_test.log`\r\n``` \r\n   75 core   0: 0x000000008000003e (0x000062f9) c.lui   t0, 0x1e\r\n   76 3 0x000000008000003e (0x62f9) x 5 0x0001e000\r\n   77 core   0: 0x0000000080000040 (0x3002a073) csrs    mstatus, t0\r\n   78 3 0x0000000080000040 (0x3002a073)\r\n```\r\nA `0x0001e000` value is written which should produce a `0x00001800` when read (MPP set to `0b11`as MPP is WARL) \r\n```\r\n  847 core   0: 0x00000000800020ec (0x30002773) csrr    a4, mstatus\r\n  848 3 0x00000000800020ec (0x30002773) x14 0x00000000\r\n```", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 70, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1742", "title": "[BUG] Inhibition of cycle counter", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nHello!\r\nI found that the current implementation of the performance counter inhibition for the cycle counter does not actually inhibit the mcycle CSR increment every cycle but simple writes to it the value of the instruction retired count.\r\n\r\nThere might be a reason for this behavior to be desirable but it does not seem to follow the RISC-V specification.\r\n\r\nhttps://github.com/openhwgroup/cva6/blob/2708df998d55bc3c826a850ef567558b29fd633c/core/csr_regfile.sv#L571-L572", "comments": ["Thanks. You are right. I submitted a PR to fix it    ( #1743 )"], "type": "hardware", "design": "default_riscv"}
{"index": 71, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1740", "title": "[BUG] : PMP CSRs", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nHello,\r\nIn the RISCV spec section **3.7 Physical Memory Protection** : \r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/f32dbb94-ffd5-463d-83bc-ec8268585407)\r\n\r\nSo in the pmpxcfg has the combination of X, W, R is reserved when W = 1 & R = 0 (as X, W, R form a collective WARL), so if we write a value in pmpxcfg which have this combination, we should clear only the bits X, W, R (normally clear W), but the CVA6 clear the entire pmpxcfg.", "comments": ["Do you mean when writing `b'xxxxxx10` where x can be 0 or 1 in a `pmpxcfg` byte, the result is `pmpxcfg` equal to 0?", "> Do you mean when writing `b'xxxxxx10` where x can be 0 or 1 in a `pmpxcfg` byte, the result is `pmpxcfg` equal to 0?\r\n\r\nyes"], "type": "hardware", "design": "default_riscv"}
{"index": 72, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1739", "title": "[BUG] : Aligned CVA6 Design with CSR embedded Doc", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nIn the [CSR embedded doc list](https://gitlab-tss.gemalto.com/riscv/ohg-pr/cva6/-/blob/9952bce6a61faa8a0c3a25e72526f0d57cb699eb/docs/csr-from-ip-xact/embedded/cva6_csr.md), there is a list of the supported CSR in the embedded application of the CVA6, the problem here that the CVA6 still have some of the unsupported CSR in the Design and it can compute read/write operation like MCOUNTINHIBIT should we aligned the design with the doc ?", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 73, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1735", "title": "[BUG] : MVENDORID Reset value", "body": "### Is there an existing CVA6 bug for this?\n\n- [x] I have searched the existing bug issues\n\n### Bug Description\n\nHello, I'm a little confuse about the reset value of MVENDORID CSR : \r\n\r\n1. RTL read 0x00000602\r\n2. The [doc](https://github.com/openhwgroup/cva6/blob/master/docs/01_cva6_user/CV32A6_Control_Status_Registers.rst#:~:text=Instruction%20Retired%20counter-,mvendorid,-0xF11) has 0x0 as reset value.\r\n\r\nfor sure there's a BUG but where ? \r\nIS it the CVA6 or the CSR documentation \r\n\r\n", "comments": ["@JeanRochCoulon probably the documentation is wrong?", "The RTL is correct (see issue #715).", "@JeanRochCoulon but in https://github.com/openhwgroup/cva6/blob/master/docs/01_cva6_user/CV32A6_Control_Status_Registers.rst ?", "#1754 requests to remove the CSR chapter from USer Manual. This GitHub issue can be close. Thank @AyoubJalali for the warning."], "type": "hardware", "design": "default_riscv"}
{"index": 74, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1734", "title": "[BUG] : MISA CSR does not implement BITMANIP extension", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nHello, Trying to cover reset value on MISA CSR for CV32A60X (embedded application), and i get that following value : **0x40001104**, and decoding tha value using the _Table 3.2: Encoding of Extensions field in misa_ in privlied RISCV spec (page 31)\r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/2afa5013-9eaf-4a00-882a-9f1c3654b388)\r\n\r\nyou can see clearly that bitmanip extension is decoded in the second bit, so the reset value isn't correct, normally as the bitmanip extension is enabled in CV32A60X the reset value should be : **0x40001106**", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 75, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1715", "title": "[BUG] No documentation on CVA 6 Boot Process", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nI need help understanding the CVA6 boot process -\r\nI created a simple bare metal set of instructions -\r\n\r\nDisassembly of section .text:\r\n\r\n0000000000000000 <main>:\r\n   0:   1101                          c.addi  x2,-32\r\n   2:   ec22                          c.sdsp  x8,24(x2)\r\n   4:   1000                          c.addi4spn      x8,x2,32\r\n   6:   4785                          c.li    x15,1\r\n   8:   fef42623                    sw      x15,-20(x8)\r\n   c:   4789                          c.li    x15,2\r\n   e:   fef42423                    sw      x15,-24(x8)\r\n  12:   fec42783                  lw      x15,-20(x8)\r\n  16:   873e                         c.mv    x14,x15\r\n  18:   fe842783                  lw      x15,-24(x8)\r\n  1c:   9fb9                         c.addw  x15,x14\r\n  1e:   fef42223                  sw      x15,-28(x8)\r\n  22:   0001                        c.addi  x0,0\r\n  24:   853e                        c.mv    x10,x15\r\n  26:   6462                        c.ldsp  x8,24(x2)\r\n  28:   6105                        c.addi16sp      x2,32\r\n  2a:   8082                        c.jr    x1\r\nand and am loading boot code through the AXI interface. It seems AXI interface reade the first several instructions and then stops \r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/61126503/a9e34576-794f-48fd-b552-2112a7bd42fb)\r\n\r\n1. Where are the registers in the device to look at the various register operations completing (verilog hierarchy) ?\r\n2. Which signal in the verilog hierarchy do I look to find if exceptions are generated ?\r\n3. Why does the AXI bus not complete reading after the first 4 DWords ?\r\nThanks,\r\nRaj\r\n\r\n", "comments": ["Hello @AEzzejjari   As you are familiar with AXI transactions, do you have some answers to @rajatkmitra questions ?"], "type": "hardware", "design": "default_riscv"}
{"index": 76, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1712", "title": "Implement Machine Environment Configuration Registers", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\n#1658 added a CSR to the CVA6. CSR documentation need to be updated accordingly.", "comments": ["BHT is a paramter, not a CSR. Close the issue."], "type": "hardware", "design": "default_riscv"}
{"index": 77, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1625", "title": "[Spike] : Mismatch of address mapping between spike & RTL", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello, \r\nSo after the merge of spike tandem, one of the directed tests that I wrote (to cover some corner cases in the ISACOV) failed, in this case spike reach  his maximum steps, so after a quick debug, I found that spike raise an exception of loadaccess_fault on an address (example : 0xffff_fff0), in the opposite side the CVA6 does raise any exception and threat the address in his valid range.\r\n\r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/c4a6feb8-37fc-4d91-b9fd-f46a289eedf5)\r\n\r\nSo to reproduce the problem you only need to execute the command line :  \r\n**### python3 cva6.py --testlist=../tests/testlist_isacov.yaml --test load_reg_hazard --iss_yaml cva6.yaml --target cv32a6_embedded --iss=vcs-uvm,spike** (run it in cva6/verif/sim) of course using the new spike (cva6 HASH 5e68fc0a3fde3333d645d0b43fbce58bebabe6cf)", "comments": ["Do we have a specification of the memory address space?", "Following the specifications, this address is out of both `ExecuteRegion` and `CachedRegion` . \r\n\r\nhttps://docs.openhwgroup.org/projects/cva6-user-manual/01_cva6_user/Parameters_Configuration.html#parameters", "Based on the User Manual info, the exception should be triggered on the RTL side in the first place.  On the Spike side the default setting is 2GB so the access should succeed unless tandem parameterization clips the range already to 1GB (32'h4000_0000).", "It clips the range to 1GB already to be aligned with the spec ", "OK, so that's an RTL issue (access outside the mapped space should be detected).  @JeanRochCoulon, what's your view on this?", "@zchamski   To my mind, test is maybe wrongly compiled/linked. Why 0xfffffff0 address is acccessed ? Of course cva6 does not implement this address but the test should not use this address.", "Looking at the code, the access is explicitly coded as `lw zero, -16(zero)`, so the compilation flow only generates the corresponding instruction.", "> OK, so that's an RTL issue (access outside the mapped space should be detected). @JeanRochCoulon, what's your view on this?\r\n\r\nAny news from the CVA6 spec and/or implementation side?"], "type": "hardware", "design": "default_riscv"}
{"index": 78, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1613", "title": "[DECODER] : Separate between RV32 & RV64 instruction", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nStill on the same issue, in the [line](https://github.com/openhwgroup/cva6/blob/3c455109348acc6061109897075af29658c37e86/core/decoder.sv#L725), REV8 has 2 instr[31:20] value to be valid instrcution, but in fact REV8 is a RV64 instruction if _**instr.instr[31:20] == 12'b011010111000**_ & it's a RV32 if **_instr.instr[31:20] == 12'b011010011000_**, so it sould add a condition on this to improve CC", "comments": ["Hello @AyoubJalali    A dediccared PR has been merged concerning this issue. If the issue is fixed, please close it (by indicating the PR number).", "No change (except the verible formatting) has been done on that line since the introduction of bitmap RTL code.", "> Hello @AyoubJalali A dediccared PR has been merged concerning this issue. If the issue is fixed, please close it (by indicating the PR number).\r\n\r\nThat's a new one", "@AyoubJalali   #1714 should have fixed this issue. If you confirm, you would have the privilege to close the issue ;-)"], "type": "hardware", "design": "default_riscv"}
{"index": 79, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1588", "title": "[Decoder] ZEXTH is a RV32 instruction", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nHello, I notice that the ZEXTH instruction is still with the RV64 instruction block (I think you missed to remove it), and I see it in 3 different place in the [decoder.sv](https://github.com/openhwgroup/cva6/blob/master/core/decoder.sv) : \r\n\r\n1. [First one](https://github.com/openhwgroup/cva6/blob/f301d6967517336a21a58c9b8a00ea3186906c01/core/decoder.sv#L596)\r\n2. [Second ](https://github.com/openhwgroup/cva6/blob/f301d6967517336a21a58c9b8a00ea3186906c01/core/decoder.sv#L639)\r\n3. [Third one](https://github.com/openhwgroup/cva6/blob/f301d6967517336a21a58c9b8a00ea3186906c01/core/decoder.sv#L671)\r\n\r\nBut the real issue here I think is [here](https://github.com/openhwgroup/cva6/blob/f301d6967517336a21a58c9b8a00ea3186906c01/core/decoder.sv#L681), because some tests failed, and i suspect this line to be the problem.", "comments": ["@fatimasaleem  Can we close this GitHub Issue after the PR merging ?", "@AyoubJalali Can you close this issue (indicate the PR number please) ?", "fix by : PR #1579"], "type": "hardware", "design": "default_riscv"}
{"index": 80, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1578", "title": "[Compressed decoder] : Missing XLEN condition on RV64C instructions", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello,\r\nTo make long story short, there's bunch of RV64C instructions without a XLEN == 64 condition, and that affect code coverage as you see : \r\n![image](https://github.com/openhwgroup/cva6/assets/110232072/6c5f7159-ca4b-4f4d-9e98-2bcd668acc8d)\r\n", "comments": ["Got it. Let me fix this in the same PR as for https://github.com/openhwgroup/cva6/issues/1565", "Thanks"], "type": "hardware", "design": "default_riscv"}
{"index": 81, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1573", "title": "[TASK] Cascade CPU fuzzing research bugs track", "body": "### Is there an existing CVA6 task for this?\n\n- [X] I have searched the existing task issues\n\n### Task Description\n\nRecently the paper: _Cascade: CPU Fuzzing via Intricate Program Generation_ showcased some bugs of the CVA6. The goal of this issue is to track which bugs have been fixed and the corresponding PR. \r\n\r\n|ID (paper) | Description| CVE|Status|\r\n|:--:|:--|:--:|:--:|\r\n|C1| Double-precision multiplications yield wrong sign when rounding down |2023-34904||\r\n|C2| Single-precision floating-point operations may treat NaNs as zeros |2023-34906||\r\n|C3| Division by NAN incorrectly sets NX and NV fflags |2023-34905||\r\n|C4| The inexact (NX) flag not set in case of overflow or underflow  |2023-34907||\r\n|C5| Division of zero by zero incorrectly sets the DZ flag |2023-34909||\r\n|C6| Plus and Minus infinity microarchitectural structures are inverted |2023-34910||\r\n|C7| Infinities are not rounded properly and stick to infinity |2023-34911||\r\n|C8| Spurious exceptions when reading some performance counters  |2023-34911||\r\n|C9| Wrong supervisor performance counter access control |2023-42311||\r\n|C10| Under some microarchitectural circumstances, wrong NAN conversion | 2023-34908 ||\n\n### Required Changes\n\nWhen a bug of the table is fixed, please link this issue with the corresponding bug ID or CVE in the PR.\n\n### Current Status\n\nIt is not straightforward to know if the bugs are already fixed.\n\n### Risks\n\n_No response_\n\n### Prerequisites\n\n_No response_\n\n### KPI (KEY Performance Indicators)\n\n_No response_\n\n### Description of Done\n\nWhen all bugs have been fixed and the status column is updated with the corresponding PR.\n\n### Associated PRs\n\n_No response_", "comments": ["Thank you for the work done on CVA6 !!   I like it!  \r\nMaybe I ask you the corresponding CVA6 hash on which the verification has been executed ?\r\nReminder: https://comsec.ethz.ch/wp-content/files/cascade_sec24.pdf", "@acaldaya  Would you be available to present the results in cva6 verification meeting ?  it is scheduled at 2pm CET on Thursday\r\n\r\n@ASintzoff moderates it", "Sorry for the confusion, it is not my research, but really interested.\r\n\r\nI will write to the authors and let them know about this thread. According\r\nto the paper, a C1 fix was merged, but I didnt find a ref of it.\r\n\r\nOn Thu, Oct 26, 2023, 07:55 JeanRochCoulon ***@***.***> wrote:\r\n\r\n> @acaldaya <https://github.com/acaldaya> Would you be available to present\r\n> the results in cva6 verification meeting ? it is scheduled at 2pm CET on\r\n> Thursday\r\n>\r\n> @ASintzoff <https://github.com/ASintzoff> moderates it\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/openhwgroup/cva6/issues/1573#issuecomment-1780460264>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AF3FKZ6CFX6II7SMKUADIE3YBH3OTAVCNFSM6AAAAAA6P6JG62VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTOOBQGQ3DAMRWGQ>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n", "@flaviens Would you be available to present the work results ?", "I have found these existing issues, which seem to be related to the report\r\nhttps://github.com/openhwgroup/cva6/issues/1213\r\nhttps://github.com/openhwgroup/cva6/issues/1212\r\nhttps://github.com/openhwgroup/cva6/issues/1192\r\nhttps://github.com/openhwgroup/cva6/issues/1091\r\nhttps://github.com/openhwgroup/cva6/issues/1071", "Hello, thank you for your interest!\r\n\r\nI would like to underline that all the bugs were reported to you many months before the paper went public, in accordance with responsible disclosure.\r\n\r\nHere are some links to help you.\r\n\r\nhttps://github.com/openhwgroup/cvfpu/issues/72\r\nhttps://github.com/openhwgroup/cva6/issues/1071\r\nhttps://github.com/openhwgroup/cva6/issues/1192\r\nhttps://github.com/pulp-platform/fpu_div_sqrt_mvp/issues/15\r\nhttps://github.com/pulp-platform/fpu_div_sqrt_mvp/issues/17\r\nhttps://github.com/pulp-platform/fpu_div_sqrt_mvp/pull/20/commits/ecfabd1f37e4354ead96bf347ab648addde42491\r\nhttps://github.com/pulp-platform/fpu_div_sqrt_mvp/pull/20/commits/de10d674cbb2da026aeb1995a3fb45c2623a3761\r\nhttps://github.com/openhwgroup/cva6/issues/1212\r\nhttps://github.com/openhwgroup/cva6/issues/1213\r\nhttps://github.com/openhwgroup/cvfpu/issues/77\r\n\r\nhttps://github.com/openhwgroup/cvfpu/pull/73\r\nhttps://github.com/pulp-platform/fpu_div_sqrt_mvp/pull/16\r\nhttps://github.com/pulp-platform/fpu_div_sqrt_mvp/pull/18\r\nhttps://github.com/pulp-platform/fpu_div_sqrt_mvp/pull/20\r\n\r\nRegarding the presentation, I must unfortunately decline for this specific time slot (this is a very short notice!).\r\n@JeanRochCoulon, if you would like a presentation or discussion, please contact me by email directly to schedule it, I'd be very glad to have the opportunity to exchange with you.\r\n\r\nKind regards,\r\nFlavien", "Additionally, @KatCe suggested that you may be interested in [this issue (Y1)](https://github.com/YosysHQ/yosys/issues/3773) as well, despite being seemingly a yosys-related issue."], "type": "hardware", "design": "default_riscv"}
{"index": 82, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1565", "title": "[Alu] : Missing condition on the XLEN for RV64B instruction", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello,\r\nI notice the in the [decoder.sv](https://github.com/openhwgroup/cva6/blob/master/core/decoder.sv), there's a RV32B instruction with RV64 instructions under the XLEN == 64 condition, [zext.h](https://github.com/openhwgroup/cva6/blob/53d388071d51f4cca018e5f4ddf08ccacb45ecff/core/decoder.sv#L657) check this out\r\n ", "comments": ["Additionally, in alu.sv, some lines should be also under same condition to remove useless code for RV32.", "Hello, I think i miss this https://github.com/openhwgroup/cva6/blob/9e47cc6947b5c47d01d2ac5c9b7e0a36b5c99627/core/decoder.sv#L629, we have the condition on these instructions on the decoder, but still we should remove zext.h from the condition because it's RV32b instruction", "So I think we should only add this condition in the ALU.sv, and also remove zext.h from RV64b instruction", "Hello @fatimasaleem \r\nAyoub has found an issue in BitManip implementation, can you confirm it and possibly propose a PR ?"], "type": "hardware", "design": "default_riscv"}
{"index": 83, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1542", "title": "[BUG] Performance counters are cleared if configured event is absent for one or more cycles.", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nIn ```core/perf_counters.sv:115``` the ```generic_counter[i]``` register is reset to 0 in every cycle, where the configured event is not present.\r\n", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 84, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1527", "title": "Throttling core in case of cache miss ", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nI have been wondering for a long time how to throttle the core if (any of the multicore) core accesses more memory. I am implementing bandwidth regulation for Real-time purposes in CVA6 multicore. At this moment I want to stick to a single core, L1 cache. Later I will go to L2 cache and multicore if it works in a single core.   \r\n\r\n\r\nDo you know any of the following tricks that can be suitable for throttling the CPU core like for example : \r\n \r\n1.\tblock icache + dcache in submitting requests to the memory subsystem on cache misses so it prevents from accessing any data  (this keeps the core running as long as its working set is in the caches)\r\n         \r\n         \r\n2.\tinsert some fake blocking in the icache\r\n   so the icache does not deliver the next cacheline on a fetch to the core \r\n   \r\n\r\n3.\tinserting pipeline bubbles in the instruction decoder\r\n   - as long as throttling is assert\r\n   - insert a fixed amount of bubbles, then ignore throttling for a fixed amount\r\n     to guarantee minimum progress \r\n\r\n\r\nWhich tricks would be most convenient to apply in CVA6 and How to apply them? Or there can be better than this. My idea is to throttle the non-real-time core so that if there a real-time need for more bandwidth. \r\n", "comments": ["C\u00e9sar, @HimalSubedi787 is searching a way to chalenge the cache. These points can be good inputs for your cache verification. I assigned you to this point as you are the more active on this topic so far.", "Hi @HimalSubedi787,\r\n\r\nFrom your proposals, I prefer the first solution because it allows the core to do some computation while being throttled if it does not access the memory. The other two solutions, stalls the core whether it does access the memory or not.\r\n\r\nA fourth solution would be to a add a throttle mechanism at the input of the NoC (between the output of the cache and the NoC). It has the advantage of being independent to the cache, and then can be used with any of the three cache subsystems proposed with the CVA6 (WT, WB, HPDcache). It also has the advantage that it works even if the core implements more than 1 level of private caches (like in the multi-core OpenPiton environment where the CVA6 has 2 levels of private caches).\r\n\r\nBest regards\r\n"], "type": "hardware", "design": "default_riscv"}
{"index": 85, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1508", "title": "[BUG] ariane_xilinx.sv debug module driving conflict", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nI believe there may be a problem with the assign statements in lines 506-559 of ariane_xilinx.sv for xlen==64 VC707 synthesis using the cv64a6_imafdc_sv39 configuration . These assign statements yield warnings during FPGA synthesis for the VC707 that master_to_dm does not have a driver. Also, when compiling in xcelium, there are errors corresponding to driving conflicts for master_to_dm[0]. Looking at these lines, e.g. assign master[ariane_soc::Debug].aw_id = master_to_dm[0].aw_id; , it appears the assign statement may be incorrect.", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 86, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1506", "title": "[BUG] Check that TVAL is well implemented in mmu32", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nRefer to #1498 ", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 87, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1480", "title": "[BUG] mconfigptr CSR is not implemented", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nIn version 1.12 of Machine ISA module (RISC-V privileged architecture version 20211203), the mandatory CSR `mconfigptr` is defined.\r\n\r\nThis CSR is missing in the current CVA6 RTL.", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 88, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1456", "title": "[BUG] Misaligned address Exception Bypass in case of no MMU", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nMMU Bypasses the Misaligned address exception information if there is not any MMU exception, from the `misaligned_exception` struct to the `mmu_exception` struct. \r\n\r\nBut when the  `MMU_PRESENT` is zero we should be able to send the misaligned exception information directly to either load unit or store unit. \r\n\r\nBut currently, in RTL the mmu_exception struct is tied to [zero](https://github.com/openhwgroup/cva6/blob/b952b0d7c3e30dbfa7dc4d89a4579307d73c7f53/core/load_store_unit.sv#L231) when `MMU_PRESENT` is zero. It should pass through the misaligned exception information instead.", "comments": ["@JeanRochCoulon This will affect the embedded configuration."], "type": "hardware", "design": "default_riscv"}
{"index": 89, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1454", "title": "[BUG] SFENCE.VMA Cases in Shared TLB", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThere are four different cases of `sfence.vma` that are used to flush the TLBs. For example, as these four cases are implemented in TLB [here](https://github.com/openhwgroup/cva6/blob/b29e07feca6720d0360302d7de8fbe10f5b29cf4/core/mmu_sv32/cva6_tlb_sv32.sv#L110). \r\n\r\nBut in the design implementation of `Shared TLB` these cases are not added. Upon committing `SFENCE.VMA`, the shared TLB is [completely](https://github.com/openhwgroup/cva6/blob/b29e07feca6720d0360302d7de8fbe10f5b29cf4/core/mmu_sv32/cva6_shared_tlb_sv32.sv#L266) flushed, which may not be the desired scenario. Shared TLB should also implement the four `sfence.vma` cases, as this will impact the performance in the long run.", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 90, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1381", "title": "[BUG] RVFI `rvfi_valid`", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nFor the [RVFI](https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md) my assumption was that the `rvfi_valid` should go high when the core retires an instruction. I thought this should also hold true for exceptions (which would count as retired instructions, but with an exception annotated).\r\n\r\nFor the current implementation this isn't the case for CSR instructions that cause an exception: https://github.com/openhwgroup/cva6/blob/f7b79535dfc6115144585cefb973894add44a85c/core/commit_stage.sv#L159\r\n\r\nMy question is this intended or necessary (because for example spike comparison requires it)? Or a bug? If the latter I could propose a fix.\r\n\r\n/cc @michael-platzer", "comments": ["Hello @zarubaf, is it the same as this issue ? https://github.com/openhwgroup/cva6/issues/1338", "@MikeOpenHWGroup as you maybe have more visibility on what has been done for embedded cores, I assigned this issue to you", "Oh yeah exactly that issue. I should have taken \r\n\r\n> I have searched the existing bug issues\r\n\r\nmore seriously. Sorry about that."], "type": "hardware", "design": "default_riscv"}
{"index": 91, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1375", "title": "Read, Write & Execution on 0x0 address  ", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello, \r\nSo I notice that the CVA6 has permission to read, wrote & execute on 0x0 address, I think it should raise an exception on lower address.\r\nto reproduce the Bug you'll find an .S\r\n\r\n[bug_test.S](https://github.com/openhwgroup/cva6/files/12560778/bug_test.S.txt)\r\n", "comments": ["This seems to be another incarnation of #1625 where CVA6 does not trap on address `0xffff_fff0`.", "what I observed is the CVA6 can read/ write and execute from address 0x0 to 0xffff_ffff (virtual address), we need to resolve this, this is not right  "], "type": "hardware", "design": "default_riscv"}
{"index": 92, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1352", "title": "Decoding RV64 as a RV32 instruction", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nI generate some illegal instruction (illegal opcode **_0x232532af_**), and I found that an instruction is actually a **RV64A**  instr, the problem is the **CV32A60X** decode it, without raising an exception.\r\nSo I think it's a BUG in the decoder, if you wanna reproduice the BUG you just need to inject the instruction 0x232532af in your test.S", "comments": ["Do you have more information about the 0x232532af instruction: mnemonic for instance. Because I did not find it in Risc-V information (maybe not up-to-date).", "> Do you have more information about the 0x232532af instruction: mnemonic for instance. Because I did not find it in Risc-V information (maybe not up-to-date).\r\n\r\nit's RV64A instruction (0x232532af) **amoxor.d t0, s2, (a0)**"], "type": "hardware", "design": "default_riscv"}
{"index": 93, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1347", "title": "Performance bug store buffer", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\n### Underutilization of the speculative store buffer\r\n\r\nFrom my understanding, the speculative store buffer should be ready to accept stores either when there is an empty buffer entry or at a commit.  In the current implementation, the store_buffer_ready signal is set in the following file.\r\n\r\ncore/store_buffer.sv:81 `ready_o = (speculative_status_cnt_q < (DEPTH_SPEC - 1)) || commit_i;`\r\n\r\nWhen this implementation was simulated using Verilator, I found out that the above condition used for setting ready_o is not the optimum. Following is the trace for the simulation I did with two speculative sore buffer entries. The two `valid` waveforms are for the two speculative store buffer entries. (Note: ready_o is connected to store_buffer_ready)\r\n\r\n![1](https://github.com/openhwgroup/cva6/assets/20531105/1b85d090-b848-493c-8b10-e81f68f90c32)\r\n\r\nIn the clock cycle that is marked, both speculative store buffers are occupied. However, in the following cycle speculative buffer 0 is ready to accept stores. This means that the  store_buffer_ready should be high. However, because of the logic used it is still low resulting in a speculative store buffer underutilization. I think the store_buffer_ready signal should be set based on store_buffer entry validness which will better utilize resources.\r\n\r\n", "comments": ["@cathales This issue is relative to performance. Maybe Have you notice this limitation ?", "@JeanRochCoulon what if we do `ready_o = (speculative_status_cnt_q < (DEPTH_SPEC)) || commit_i;` instead of `ready_o = (speculative_status_cnt_q < (DEPTH_SPEC - 1)) || commit_i;`. I think this will resolve this limitation.", "Hi @YasasSeneviratne  can you confirm that [PR#1349](https://github.com/openhwgroup/cva6/pull/1349) resolves this for you as well? Thanks"], "type": "hardware", "design": "default_riscv"}
{"index": 94, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1345", "title": "PMU counter, L2 chache, CC ( cache coherence ) ( Questions about CVA 6)", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nIs the PMU counter being implemented in the L2 cache? \r\n\r\n1. Does cva6 have a performance monitoring unit/counter (PMU/PMC)? If yes, can you please show me a direction in Git Hub? \r\n\r\n2. I also wonder how to track the traffic at the L1 cache level.  \r\n3. Which kind of cache coherence protocol is implemented? &  How is it implemented? Can you please show me a direction in Git Hub? \r\n\r\n \r\n\r\n", "comments": ["Hi @HimalSuebdi , \r\n\r\n1. Currently, CVA6 can only use the L2 Cache of OpenPiton's mesh, there is not any L2 Cache available in the CVA6 repo.\r\n2. CVA6 is using write-through L1 data cache, which you can track by tracking [dcache_req_ports_i](dcache_req_ports_o ) & [dcache_req_ports_o](https://github.com/openhwgroup/cva6/blob/e1c40c5dcf89e2bf8b2d26349778d59742c013ed/core/cva6.sv#L921C6-L921C25)  in CVA6 top.\r\n3. Since only L1 write through cache subsystem is present, there is not need to have any cache coherency protocol in CVA6. \r\nBut you can find the coherency protocol in openpiton mesh, [here](https://parallel.princeton.edu/openpiton/docs/micro_arch.pdf) is a documentation link for it.\r\n", "@HimalSuebdi \r\nAre you satisfied by @fatimasaleem answer ?  In that case, can you close the issue\r\nThanks"], "type": "hardware", "design": "default_riscv"}
{"index": 95, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1338", "title": "RVFI Limitation", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello,\r\nthis issue is about the **RVFI** tracer that drive all sort of information related to an instruction _(GPR, PC, CSR , MEM_ADDR ...)_, the problem or the limitation in this tracer is that it can't drive information of an instruction does not been committed (killed or raised an exception), I really want to think about a possibility to update this tracer to be more practical in that way, because it affect **ISACOV** coverage.", "comments": ["To my mind, an information is missing: getting an exception without the related instruction is a mess to monitor the cva6 behaviour. I confirm the need to fix it.", "Related to #1441 \r\nRVFI will be revisited by @Gchauvon, I reassigned this issue.", "Please keep in mind that we want to use the [OpenHW version of RVFI](https://docs.openhwgroup.org/projects/cv32e40s-user-manual/en/latest/rvfi.html), as specified in the CV32E40S User Manual.  It is a super-set of the SymbioticEDA version and contains information needed to operate the ISS as a reference model (e.g. Spike Tandem)."], "type": "hardware", "design": "default_riscv"}
{"index": 96, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1332", "title": "unnecessary logic", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThis cannot be counted as bug but I couldn't find a relevant label. The tools already handle it. However, It is better to simple as much as possible. That's why I wanted to ask whether[ this line ](https://github.com/openhwgroup/cva6/blob/a052d4f2d54061e788924f7f3d1fa8e5933c0980/core/csr_regfile.sv#L873)includes unnecessary logic or not. \r\n\r\nLet say `!pmpcfg_q[index].locked` `a`, and `pmpcfg_q[index].locked && pmpcfg_q[index].addr_mode == riscv::TOR` `b`.\r\nthe if statement depend on `a.(a'.b)'`\r\n`= a.(a+b')`\r\nWhich is `a` so the actual if statement must depend on `!pmpcfg_q[index].locked` ", "comments": ["Thanks for the report! I think there might be a `+1` missing. According to the comment, it should be: \r\n\r\n```systemverilog\r\n// check if the entry or the entry above is locked\r\nif (!pmpcfg_q[index].locked && !(pmpcfg_q[index+1].locked && pmpcfg_q[index].addr_mode == riscv::TOR)) begin\r\n```\r\n\r\nCould you open a PR with this change?", "I made it but it is auto-blocked. Did I made something wrong?", "Could you sign the eclipse agreement with the same email that you made the commit? Also, you might need to sign the commit with `git commit --amend -s`. ", "Should I make a new pull request?\r\nI sign the eclipse agreement but I was made PR from Web. To run this command `git commit --amend -s` I need to clone project right?\r\n", "I think it will take your time than necessary. Is it better to make this change by an active developer?", "Alright, I created a new PR with your fix: #1335 "], "type": "hardware", "design": "default_riscv"}
{"index": 97, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1322", "title": "Resolve CI ASIC synthesis regression", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThere is somehow a synthesis regression in #1317 that needs to be resolved according to @JeanRochCoulon.", "comments": ["@ASintzoff  ASIC synthesis is down.  Can you provide information to @domenicw to solve this regression ?", "ASIC synthesis is fixed. "], "type": "hardware", "design": "default_riscv"}
{"index": 98, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1306", "title": "[BUG] Failure of AXI atomic transaction", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nIn case of an AXI atomic transaction, the CVA6 crashes when we send the read data before receiving the write data of the same transaction.", "comments": ["Thanks for reporting. Any chance that there is a minimal test you can provide, so that we can reproduce and fix?", "@JeanRochCoulon is that anything we can track in the DV Plan?"], "type": "hardware", "design": "default_riscv"}
{"index": 99, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1301", "title": "[BUG] Infinite loop in std_cache_pkg::one_hot_to_bin()", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nIf the `in` input to the [std_cache_pkg::one_hot_to_bin()](https://github.com/openhwgroup/cva6/blob/513bb91f823a18a6653a1685acd60408049c9c8f/core/include/std_cache_pkg.sv#L78) function is 0 and  `ariane_pkg::DCACHE_SET_ASSOC` is a power of 2 then this function enters an infinite loop since the loop variable`i` wraps from DCACHE_SET_ASSOC-1 to 0 and the loop condition is always true.\r\n\r\nChanging the type of `i` to `int unsigned` resolves this issue.", "comments": ["@fatimasaleem I think this was caused by your pull request https://github.com/openhwgroup/cva6/pull/1297", "> @fatimasaleem I think this was caused by your pull request #1297\r\n\r\nThank you @maxbjurling for pointing this out, I will try to resolve this lint warning with a different approach.", "There is a common cell for this:\r\nhttps://github.com/pulp-platform/common_cells/blob/master/src/onehot_to_bin.sv\r\n Maybe replacing `std_cache_pkg::one_hot_to_bin()` with this might be a solution?", "@niwis Reverting the single line that was changed in #1297 seems more straightforward than replacing a function call with a module instantiation. At least as an initial solution.", "@maxbjurling    Can you confirm the bug is fixed and close this issue ?   Thank you BTW for your finding", "Bug is fixed. Thank you!"], "type": "hardware", "design": "default_riscv"}
{"index": 100, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1300", "title": "[BUG] About four-byte alignment on target addresses of control transfer instructions (branch_unit.sv) ", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nHi,\r\n \r\nIn `core/branch_unit.sv` the `branch_exception_o.valid` is raised high only if the branch/jump target address is not aligned **on a two-byte boundary** ([line 94](https://github.com/openhwgroup/cva6/blob/513bb91f823a18a6653a1685acd60408049c9c8f/core/branch_unit.sv#L94C8-L96C10) checks only the LSB). That is, it enforces only two-byte boundary check, and does not raise exception when target address of JAL/JALR is not four-byte aligned. \r\nHowever, in RISC-V 2.1 specification p.16 says \"The JAL and JALR instructions can generate a misaligned instruction fetch exception if the target address is not aligned to a four-byte boundary.\"\r\n\r\nIf my understanding is correct, I think the fix may need to change the condition of [line 94](https://github.com/openhwgroup/cva6/blob/513bb91f823a18a6653a1685acd60408049c9c8f/core/branch_unit.sv#L94C8-L96C10) from. \r\n`if (branch_valid_i && target_address[0] != 1'b0) branch_exception_o.valid = 1'b1;` to   \r\n`if (branch_valid_i && (target_address[1:0] != 2'b00)) branch_exception_o.valid = 1'b1;`\r\n\r\nThanks!\r\n \r\n\r\n", "comments": ["@yaohsiaopid   Thank you for this bug finding. Can you submit a PR to fix it ?", "I submitted #1690 ", "I think the elaboration condition for C extension should be considered in the condition:\r\n\r\n> Instruction-address-misaligned exceptions are not possible on machines that support extensions\r\nwith 16-bit aligned instructions, such as the compressed instruction-set extension, C.\r\n\r\nVolume I: RISC-V Unprivileged ISA V20191213, page 21"], "type": "hardware", "design": "default_riscv"}
{"index": 101, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1234", "title": "[BUG] <Unrecognized an illegal instruction >", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello,\r\nso in order create several test to cover all possible instruction in ISA spec, I try also to inject some illegal instructions in some test,\r\nso the surprise is that the CVA6 didn't raise an exception on an illegal instruction (0x09994433), and continue to execute next instruction without raising an exception : 09994433 => b0000 1001 1001 1001 0100 0100 0011 0011 (illegal funct7 = 0000 100)\r\n\r\nso to reproduce the bug you just need to insert _.4byte 0x09994433_ in your Assembly test or : \r\n\r\n- Add the yaml description of the test in [cva6_base_testlist.yaml](https://github.com/openhwgroup/core-v-verif/blob/master/cva6/sim/cva6_base_testlist.yaml) \r\n\r\n**- test: riscv_arithmetic_basic_illegal\r\ndescription: >\r\nArithmetic instruction test, no load/store/branch instructions\r\ngen_opts: >\r\n+instr_cnt=500\r\n+num_of_sub_program=0\r\n+no_data_page=1\r\n+no_branch_jump=1\r\n+boot_mode=m\r\n+no_csr_instr=1\r\n+illegal_instr_ratio=100\r\n+tvec_alignment=8\r\niterations: 2\r\ngen_test: riscv_instr_base_test\r\nrtl_test: core_base_test**\r\n\r\nand run the commend : _python3 cva6.py --testlist=cva6_base_testlist.yaml --test riscv_arithmetic_basic_illegal --iss_yaml cva6.yaml --target cv32a60x --iss=vcs-uvm,spike -i 10 --simulator_yaml ../env/corev-dv/simulator.yaml --iss_timeout 300 --seed 3512599541_ in core-v-verif/cva6/sim (branch cva6/dev & RTL matser), normally you should get your failing test (the 3th one)", "comments": ["`0x09994433` corresponds to the RV32 bitmanip `ZEXT.H` instruction.\r\nThe code at https://github.com/openhwgroup/cva6/blob/master/core/decoder.sv#L508 (`{7'b000_0100, 3'b100}: instruction_o.op = ariane_pkg::ZEXTH;`) shall be valid only when bitmanip extension is enabled."], "type": "hardware", "design": "default_riscv"}
{"index": 102, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1424", "title": "Verification goal for FENCEI feature in CVA6 DV plan", "body": "The [verif goals](https://github.com/openhwgroup/core-v-verif/blob/ddcc187fdf34901dd22967a5656a910ddc850258/cva6/docs/VerifPlans/FENCEI/VP_IP001.yml#L25) for this feature does not guarantee that the fencei instruction has worked. If the instruction following the fencei has not yet been pre-fetched then the newy stored value will always be executed. A proper test of a fencei requires the following scenario:\r\n\r\n- The instruction immediately before fencei, the fencei instruction and the instruction immediately following fencei are fetched into the CVA6.\r\n- The fencei instruction causes the instruction immediately following fencei to be fetched a second time.\r\n- The test-program checks that the modified, not original instruction immediately following fencei is executed.", "comments": ["If I really assimilate your note, you are suggesting the hole verif plan should be updated (this is exacly what I'm working on ; updating in parallel with the verification process). ", "Hi @YoussraBELAMKADEM, what is the status of this Issue?"], "type": "hardware", "design": "default_riscv"}
{"index": 103, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1214", "title": "non-8-byte-aligned AMO operations", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThe #1003 PR detects maybe a bug. The scope of the Github issue is to log the potential bug. Investigation will be done during AMO verification.\r\n ", "comments": ["#1003 fixes (and closes) the issue"], "type": "hardware", "design": "default_riscv"}
{"index": 104, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1212", "title": "[BUG] Missing required CSRs: mhpmevent9-31", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\nHi there!\r\n\r\n### Bug description\r\n\r\nThe privileged specification says, in section `3.1.10`:\r\n\r\n> All counters should be implemented, but a legal implementation is to make both the counter and its corresponding event selector be read-only 0.\r\n\r\nHowever, reading any of mhpmevent9 to mhpmevent31 raises an exception. \r\n\r\n### Example snippet\r\n\r\nThis snippet should store 0 to address 0x10 but stores 1 instead.\r\n\r\n```\r\n  .section \".text.init\",\"ax\",@progbits\r\n  .globl _start\r\n  .align 2\r\n_start:\r\n\r\n  la \t  ra, trap_handler\r\n  csrrw\tzero,mtvec,ra\r\n  csrr\tzero,mhpmevent9\r\n\r\n  li a0, 0x10\r\n  li t0, 0\r\n\r\n  sd t0, (a0)\r\n  sd zero, (zero)\r\n\r\ninfinite_loop0:\r\n  j infinite_loop0\r\n\r\n.section \".trap_handler\",\"ax\",@progbits\r\ntrap_handler:\r\n\r\n  li a0, 0x10\r\n  li t0, 1\r\n\r\n  sd t0, (a0)\r\n  sd zero, (zero)\r\n\r\ninfinite_loop1:\r\n  j infinite_loop1\r\n```\r\n\r\nThanks!", "comments": ["Thanks for the issue and associated code snippit @flaviens.  I must admit I am a bit confused:\r\n\r\n>However, reading any of mhpmevent9 to mhpmevent31 raises an exception.\r\nThis snippet should store 1 to address 0x10 but stores 0 instead.\r\n\r\nMy read of your code is exactly inverted: an exception writes 1 to 0x10. If you are seeing 0 written to 0x10 then there was no exception (as expected).\r\n\r\n", "Hi @MikeOpenHWGroup , sorry I mixed up 1 and 0 in the post above. We expect 0 but we get 1. I edited it in place.", "@TulikaSi   can you give us more visibility on this bug ?   Is it prensent in current RTL ?", "Hi @flaviens @JeanRochCoulon \r\nmhpmevent CSRs are already present in CVA6. \r\n@flaviens Can you run the test again and let me know if the CSRs are still not accessible?\r\n ", "Can you please try to use Cascade and see how it goes? Please let me know if you encounter any difficulty.", "Hi @flaviens \r\nWe ran a testcase to read the **mhpmevent9 CSR** recently . I have attached the snips of the logfile and the testcase for your reference. As we can see from the log file that the current RTL behaves properly and does not raise an exception that clearly indicates the mhpmevent has been implemented as per the RISC-V specification. I did not use Cascade but I believe this small testcase can help us to close the issue.\r\n\r\n![mhpmevent_log_1](https://github.com/openhwgroup/cva6/assets/98868403/208032f6-99fb-4a48-aa6a-e3b7607de7f8)\r\n\r\n![mhpmevent_testcase](https://github.com/openhwgroup/cva6/assets/98868403/56923661-04b1-4ce7-9f19-e0f8b27a27c4)\r\n\r\n\r\n@JeanRochCoulon ", "Also,\r\nThis PR (https://github.com/openhwgroup/cva6/pull/1227 )done on 10th May covers the mhpmevent9-31 and the issue was raised by you on 27th April so maybe you got this error at the time these CSRs were not implemented.\r\n", "Looks good thanks for the fix!"], "type": "hardware", "design": "default_riscv"}
{"index": 105, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1202", "title": "CVA6 Custom CSRs Address Configuration Issue ", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHi,\r\n\r\nWhile verifying access modes for CVA6 CSRs, I found an issue on custom CSRs(ICACHE and DCACHE) address configuration as mentioned below.\r\n\r\nAs per riscv priviliged specification address for RW custom CSRs will be in range of 0x7C0-0x7FF or 0xBC0-0xBFF, but in CVA6 core address for custom CSRs are in range of **0x700-0x77F** which is for Standard read/write.\r\n\r\nplease find below snaps for better understanding. \r\n\r\nCVA6 Custom CSRs address range as per [CVA6 user manual](https://github.com/openhwgroup/cva6/issues/new?assignees=&labels=Type%3ABug&template=bug.yaml&title=%5BBUG%5D+%3Ctitle%3E) is as shown below.\r\n\r\n![image](https://user-images.githubusercontent.com/103561542/233372060-22c1fede-edd0-4d04-83d1-0a32bfa19e26.png)\r\n\r\n\r\n\r\nAs per riscv priviliged specification address range will be as shown below.\r\n![image](https://user-images.githubusercontent.com/103561542/233371257-3c7aa35a-a669-4d30-bb37-2fd6c9d6a628.png)\r\n\r\n\r\nThanks,\r\n\r\n\r\n", "comments": ["@RanjanThales ", "I pushed a commit to solve this issue. Please review it and close it if there is no problem. @spidugu444", "sure @frikhaAziz, I will let you know.", "@frikhaAziz, good day. Your RTL tweaks have allowed me to access the ICACHE and DCACHE CSRs at a custom read/write address range at 0x7C0-0x7C1.", "@JeanRochCoulon, On the spike end, the custom CSRs ICACHE and DCACHE have not been implemnted.", "Hi @spidugu444, it seems that the original problem reported in this issue has been solved by @frikhaAziz.  If you agree please:\r\n- close this issue.\r\n- open a new issue against the Spike model to get the custom CSRs implemented.", "Closing this issue as I raised a new [issue](https://github.com/openhwgroup/cva6/issues/1346) for CVA6 CSRs spike discrepancies.\r\n"], "type": "hardware", "design": "default_riscv"}
{"index": 106, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1192", "title": "[BUG] In new FPU, division by NAN incorrectly sets NX and NV fflags", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nI create a new issue, similar to #1071, but this affects the new FPU and changed the fflags signature.\r\n\r\nI discovered that with the new FPU, Ariane unexpectedly sets the NV (invalid operation) and the NX (inexact) flags when we call `fdiv.s` on floating-point operands that have the 32 lower bits as zeros but are NaNs.\r\n\r\nExample snippet to reproduce:\r\n```\r\n  .section \".text.init\",\"ax\",@progbits\r\n  .globl _start\r\n  .align 2\r\n_start:\r\n\r\n  # Enable the FPU\r\n  li t0, 0x2000\r\n  csrs mstatus, t0\r\n  csrw\tfcsr,x0\r\n\r\n  la t0, .fdata0\r\n  la t1, .fdata1\r\n  fld ft0, (t0)\r\n  fld ft1, (t1)\r\n\r\n  fdiv.s ft2, ft0, ft1\r\n  csrr t2, fflags\r\n\r\ninfinite_loop:\r\n  j infinite_loop\r\n\r\n.section \".fdata0\",\"ax\",@progbits\r\n  .8byte 0x49a3e80e00000000\r\n.section \".fdata1\",\"ax\",@progbits\r\n  .8byte 0xa81ad47700000000\r\n```\r\n\r\nFrom spike, fflags should be clear, but Ariane sets fflags=0x18, which corresponds to NV | NX.\r\nLet me know if I can help debug that.\r\n\r\nThanks!\r\nFlavien", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 107, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1186", "title": "[BUG] <AXI response signals are not supported in all access modes>", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThe master can know the status of a transaction by decoding the response information from the subordinate in the response signal X_RESP. \r\n\r\nThis signal is supported by the CVA6 in exclusive mode, where it must be equal to EXOKAY (x_resp = '01) to indicate that the transaction has passed. In another access mode, it can be equal to any value.  So we can inject errors and CVA6 does nothing. The specification says that the EXOKAY can only be given in response to an exclusive read or write.\r\n\r\nMy point is that we have a signal that is only supported in one access mode, not in the others, and I think this is a bug.\r\n", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 108, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1166", "title": "[BUG] rvfi_pkg duplication", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHello @JeanRochCoulon,\r\n\r\nCurrently, there two different files that define the rvfi_instr_t:\r\n\r\n1. core/include/ariane_rvfi_pkg.sv\r\n2. corev_apu/tb/rvfi_pkg.sv\r\n\r\nBoth files are identical except for the rvfi_port_t type definition in file 1. This additional definition is used by the rvfi port in the cva6/ariane modules.\r\n\r\nIn addition, the rvfi_tracer module, which allows to dump rvfi instructions into a file, is defined in corev_apu/tb/rvfi_tracer.sv. This file uses the definition in package rvfi_pkg (file 2).\r\n\r\nTo avoid redundancy, and the consequent risk of misalignment between both files above, should not be one of them removed ? As mentioned above, both are currently in used, the first to define ariane port, and the second by the rvfi_tracer. I guess the easier thing to do is:\r\n- modify the rvfi_tracer to use the ariane_rvfi_pkg\r\n- remove the corev_apu/tb/rvfi_pkg.sv file\r\n\r\nNOTE: the ariane_rvfi_pkg file is already listed in the Flist.cva6 manifest.\r\n\r\nRegards,\r\n\r\nC\u00e9sar", "comments": ["Good topic !\r\n\r\nAt the starting point, the idea was to get a rvfi package shared with other cores. That's the reason why corev_apu/tb/rvfi_pkg.sv was created. But to get cva6 RTL autonomous, a recopy has been done in cva6 RTL.\r\n\r\nWe could have the same type of discussion with AXI. AXI package is defined outside CVA6, but ariane_AXI has been created to make it autonomous.\r\n\r\nMaybe the best think to do would be to vendorize AXI and RVFI, and to link to these files. What do you think ?", "Hello @JeanRochCoulon,\r\n\r\nYes, I think that is the more appropriate way to do it. In my humble opinion, duplication is evil (difficult to maintain and prone to misalignment bugs).\r\n\r\nAXI is already vendorized (vendor/pulp-platform/axi) and @niwis already started the work of passing AXI parameters and definitions through module's parameters. There are still some places where the ariane_axi_pkg is used though. But I think they can be easily removed.\r\n\r\n", "Hello @cfuguet   2 PRs have been merged to fix the github issue #1182  and #1179.  If you are ok with the fix, can you close the github issue ?"], "type": "hardware", "design": "default_riscv"}
{"index": 109, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1161", "title": "MIP CSR is failing while verifying access mode", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nWhile verifying Access mode for MIP(Machine Interrupt Pending) CSR on CVA6 core, test got failed on RTL end due to the default reset value as it is reading as 0x00000080.\r\nAs per riscv priviliged specification default reset value for MIP CSR is 0x00000000. \r\n\r\n\r\nFor quick reference please find attached log files.\r\n[riscv_vcs_mip_csr_test_0.log](https://github.com/openhwgroup/cva6/files/11136877/riscv_vcs_mip_csr_test_0.log)\r\n[riscv_spike_mip_csr_test_0.log](https://github.com/openhwgroup/cva6/files/11136878/riscv_spike_mip_csr_test_0.log)\r\n\r\nNote: on spike end test is working fine.\r\n", "comments": ["Hi @frikhaAziz, can you have a look at this one?", "Hi @ASintzoff.  @JeanRochCoulon let me know that @frikhaAziz has completed his internship, so I am assigning this one to you.", "CSR mip: 0x00000080 => bit 7 (mip.MTIP) is set"], "type": "hardware", "design": "default_riscv"}
{"index": 110, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1160", "title": "[BUG] mstatush is not implemented in RV32", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThe `mstatush` CSR which contains the 32 most significant bits of `mstatus` CSR in RV32 is not implemented.\r\n\r\nFor more details, see The RISC-V Instruction Set Manual Volume II: Privileged Architecture, section 3.1.6 - Machine Status Registers (`mstatus` and `mstatush`).", "comments": ["Hi @ASintzoff, I took the liberty of adding `Component` and `Status` labels.  Also, the issue was not assigned and since I am unsure who will update the RTL, I assigned the issue to you.  :stuck_out_tongue_winking_eye:.  You will know better than me who the proper victim should be.", "Hello, so as I can't modify the issue to add how to reproduce the bug i'll give it here : \r\nSo I was working on adding tests on the CI for ISACOV agent, and i had a failing test so i reproduce the test, and found the bug mention above so to reproduce it here is the steps : \r\n\r\n1. Add the yaml description of the test in [cva6_base_testlist.yaml](https://github.com/openhwgroup/core-v-verif/blob/master/cva6/sim/cva6_base_testlist.yaml) (i'm working on a PR to merge this also)\r\n**### - test: riscv_arithmetic_basic_illegal\r\n  description: >\r\n    Arithmetic instruction test, no load/store/branch instructions\r\n  gen_opts: >\r\n    +instr_cnt=500\r\n    +num_of_sub_program=0\r\n    +no_data_page=1\r\n    +no_branch_jump=1\r\n    +boot_mode=m\r\n    +no_csr_instr=1\r\n    +illegal_instr_ratio=100\r\n    +tvec_alignment=8\r\n  iterations: 2\r\n  gen_test: riscv_instr_base_test\r\n  rtl_test: core_base_test**\r\n3. and run the commend : **python3 cva6.py --testlist=cva6_base_testlist.yaml --test riscv_arithmetic_basic_illegal --iss_yaml cva6.yaml --target cv32a60x --iss=vcs-uvm,spike -i 10 --simulator_yaml ../env/corev-dv/simulator.yaml --iss_timeout 300 --seed 1391044193** in core-v-verif/cva6/sim (branch cva6/dev & RTL matser), normaly you should get your failing test (the 6th one)"], "type": "hardware", "design": "default_riscv"}
{"index": 111, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1131", "title": "mstatus CSR is failing while verifying access mode. ", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nWhile verifying access mode for MSTATUS CSR, Test got failed on RTL end due to reading nonzero values on reserved fields, while on spike end reserved fields are reading with zero.\r\n\r\nplease find the steps to replicate issue.\r\n\r\n1. git clone https://github.com/spidugu444/core-v-verif.git\r\n2. git check out csr_mstatus_access_verification\r\n3. set toolchain to RISCV varible\r\n4. Run MSTATUS test by using **source cva6/regress/dv-riscv-csr-access-test.sh**\r\n5. output directory will generate inside cva6/sim \r\n6. MSTATUS test and Yaml file location:  cva6/tests/custom/csr_access_tests\r\n\r\n\r\n", "comments": ["Hello @spidugu444,\r\n@frikhaAziz has just fixed the issue with PR #1257. Can you double check and close the issue if it is the case ?", "Sure @JeanRochCoulon, I will double check this and update the status.", "HI @JeanRochCoulon, \r\n\r\nwith the updated CVA6 I am reading RTL value for MSTATUS CSR as 0x007E1FEA, previously it is 0x7FFE1FEE.\r\n\r\nWith updated RTL reserved fields in bit [2], bit [30:23] is reading zeros which is working fine.\r\n\r\nIn CVA6 user Manual bit [6], bit[10:9] fields named as reserved but in riscv privileged 20211203 specification those fields are marked as UBE and VS with access type as WARL which is as shown below.\r\n\r\nI believe cva6-user-manual and riscv privileged 20211203 specification has not compliance here.\r\n\r\ncva6-user-manual:\r\n![image](https://github.com/openhwgroup/cva6/assets/103561542/c0b5dd8a-8dd5-4413-92e1-aeb291220a84)\r\n\r\n\r\n riscv-privileged-20211203 specification\r\n![image](https://github.com/openhwgroup/cva6/assets/103561542/f1b6f29a-2eb8-4d6d-9f1f-b281489f7665)\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n", "@RanjanThales ", "@MikeOpenHWGroup @spidugu444 I just added the fields VS and UBE in #1308 to make it compliant to risc-v privileged 20211203. ", "Hi @spidugu444, please re-test this CSR access mode again against the latest RTL.", "With @frikhaAziz  fixes on RTL end test is working fine, but on spike end there are some discrepancies for FS and UBE field. \r\nI am closing this issue as I addressed spike discrepancies in this [issue](https://github.com/openhwgroup/cva6/issues/1346).\r\n"], "type": "hardware", "design": "default_riscv"}
{"index": 112, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1116", "title": "minstreth CSR is failing while verifying access modes", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nAs per riscv priviliged specification **minstreth CSR return bits 63\u201332 of machine instructions retired counter**.\r\n\r\nWhile trying to verify access modes for minstreth CSR test is failing on verilator end as it is always reading Zero.\r\nwhereas on spike end test is reading expected values and test is passing.\r\nFor reference please find attached spike and verilator log files\r\n\r\n[riscv_spike_minstreth_csr_test_0.log](https://github.com/openhwgroup/cva6/files/10976594/riscv_spike_minstreth_csr_test_0.log)\r\n[riscv_verilator_minstreth_csr_test_0.log](https://github.com/openhwgroup/cva6/files/10976599/riscv_verilator_minstreth_csr_test_0.log)\r\n", "comments": ["Thanks @spidugu444 for having reported this issue. The concern is that so far no designer has been identified to fix the RTL. The main thing is the fact that the issue is tracked. ", "Hi @Moschn, with your fix test is working fine, Thanks for your fix.\r\nI am closing this issue.\r\n", "@spidugu444  do you have double checked that the PR fixes the bug before closing the Issue ?", "HI @JeanRochCoulon, before closing the issue I confirmed it by running arch-test suite regression and minstreth CSR access mode test.\r\nplease find the attached minstreth CSV files for your reference.\r\n\r\n[riscv_spike_minstreth_csr_test_0.csv](https://github.com/openhwgroup/cva6/files/10987385/riscv_spike_minstreth_csr_test_0.csv)\r\n[riscv_verilator_minstreth_csr_test_0.csv](https://github.com/openhwgroup/cva6/files/10987386/riscv_verilator_minstreth_csr_test_0.csv)", "Great !   Thanks Sai, have a nice day"], "type": "hardware", "design": "default_riscv"}
{"index": 113, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1109", "title": "[BUG] Dependency exists between module input parameters", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\n@Nils Wistoff @Florian Zaruba,   In the ARA PR, AXI parameters are defined as seen below. I think this code cannot work. As example, when AxiAddrWidth is defined by ariane module (which instantiates cva6) and axi_ar_chan_t is not defined by ariane module, axi_ar_chan_t will be defined from ariane_axi::AddrWidth, which is not the wanted value. Because in that case, axi_ar_chan_t should be defined from AxiAddrWidth.  Tell me if I am wrong !\r\nMoreover, almost all the parameters are defined in config package, why defining them in the module parameter ?   Code would be simpler by defining parameters always with the same strategy. If you need a special configuration for ARA, what I can understand of course, you can add an ARA configuration to the cva6 repository.\r\n![image](https://user-images.githubusercontent.com/56552370/223958207-c9cedefb-34c1-4774-a82a-3ca2577185b4.png)\r\n", "comments": ["Hi @JeanRochCoulon, this is actually not in the Ara PR (anymore), but it was merged into master in #982 and #1103\r\n\r\nI don't see the bug. Both `AxiAddrWidth` and `axi_ar_chan_t` are passed from `ariane` to `cva6` [here](https://github.com/openhwgroup/cva6/blob/fdc7216920f6d8ea2474b9ecca8b82da86295814/core/ariane.sv#L62-L71), or am I missing something? Of course, we will need to rebase the Ara branch onto `master` now that those changes have been moved to separate PRs.\r\n\r\n`axi_ax_chan_t` depends not only on the address width but also on the id and user width. But I think it should also be possible to pass these values and re-define the channel types within `std_subsystem` where they are used. I think this is a matter  of preference.\r\n\r\nAre you suggesting moving these parameters to `ArianeCfg` or `cva6_config_pkg`? I think the latter would make it more difficult to pass these parameters from a system that instantiates CVA6.\r\n\r\nPS: Not sure how interested Florian Hartmann and Nils Schnabel are in this discussion :-)", "Hi,\r\nThe bug occurs when defining AxiAddrWidth without defining axi_ar_chan_t.\r\nCVA6 is configured by cva6_config_pkg: Jonathan Balkin added https://github.com/openhwgroup/cva6/blob/master/core/include/cv64a6_imafdc_sv39_openpiton_config_pkg.sv for instance. I suggest you to create a dedicated cva6_HW_config for ARA and define AXI paramaters inside: accelarator port ? FPU SIMD ? scoreboard entry number? extension A? extension C? .... ", "> The bug occurs when defining AxiAddrWidth without defining axi_ar_chan_t\r\n\r\nThat is not a legal configuration. Either you rely on the package or you need to overwrite both.", "By defining a structure, as done for arianecfg, the user would be constraint to define all the members of the structure. That's a way to avoid illegal configuration. And it would generate a code more compact !", "This is fixed!"], "type": "hardware", "design": "default_riscv"}
{"index": 114, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1106", "title": "[BUG] Out-of-Order Not Working", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\n## Bug Explanation\r\n\r\nI noticed the docs say that Out-of-Order can occur between the multiplier and the ALU, however this is not the case according to the RTL.\r\n\r\nDocs:\r\n\r\nhttps://github.com/openhwgroup/cva6/blob/a29b231070f2dccca53eae2681120116633a4ffc/docs/03_cva6_design/issue_stage.md?plain=1#L42-L54\r\n\r\nRTL:\r\n\r\nhttps://github.com/openhwgroup/cva6/blob/adf99b53042d2b14cbbb36689babf8cd4c03cf81/core/issue_read_operands.sv#L135-L152\r\n\r\nFor example, I have this code snippet:\r\n\r\n```\r\n        div     t2, t0, t1\r\n        fsqrt.s f1, f1\r\n        lw      t5, 0(s1)\r\n        add     t6, t0, t1\r\n```\r\n\r\nAnd this is it's execute stage:\r\n\r\n![image](https://user-images.githubusercontent.com/43790149/223483191-73f6885e-c1e1-4930-bf28-4377288d72b6.png)\r\n\r\nAs you can see, the `add` instruction isn't run until after the `div` finishes.\r\n\r\n## Proposed Fix\r\n\r\nEither:\r\n\r\n* The RTL could be changed to separate the ALU and multiplier into two separate busy signals.\r\n* The example in the docs could be changed to something else, such as `div` and `lsu`.", "comments": ["If you like, I can submit a pull request changing the docs to give div and lsu as the example", "Hello @sifferman and thanks for opening this issue.\r\n\r\nI had a look, I think I have found a too strict restriction (#1230) related to `mult -> *` sequences. However it does not seem to fix this issue about `div -> flu` sequences.\r\n\r\nThe parallelism is only possible for units spread on different result buses, so that their result can be provided to the scoreboard without conflicts. For the `div -> add` sequence you show, they use the same result bus (named `flu` as \"fixed latency unit\", even if div does not have a fixed latency), so you are right, the doc example is wrong.\r\n\r\nA few suggestions/ideas:\r\n\r\n- We can update the docs as you suggest.\r\n- We could add a write-back port for `mult/div` but we won't as the area cost would be considerable!\r\n- We can check if there is a minimal latency for div; if so, maybe we could issue a few other FLU\u00a0instructions just after the `div` starts?\r\n- Maybe we could modify how the div result is handled: when div result is available, if result bus is available then push the result, else store it in a (new?) register and lock the `flu` issues until the result bus is available, then release the lock and push the result.\r\n- Maybe we could move the `mult/div` unit to the same port as FP operations?", "Thanks for taking a look @cathales! I agree with your observations.\r\n\r\nActually, I believe that the throughput could increase quite a bit if the mult/div unit uses the FP port. On a mult/div instruction, it's probably more likely that the next instruction will be an ALU instruction than a FPU instruction. But I'm not sure how big of an endeavor it would be to complete this.\r\n\r\nI will have time to look into it in about a month if progress hasn't been made on it sooner", "If we move mult/div to FP port, I hope multiply-accumulate would not need bubbles anymore if the compiler is smart enough to avoid RAW hasards like below:\r\n\r\n```asm\r\nmul m0, a, b\r\n; begin repeat\r\nmul m1, a, b ; issue ok\r\nadd r, r, m0 ; now: bubble because same bus than previous mul -> after modification: issue ok\r\nmul m0, a, b ; issue ok\r\nadd r, r, m1 ; bubble -> issue ok\r\n; end repeat\r\nadd r, r, m0 ; issue ok\r\n```\r\n\r\nHowever, if the compiler does not do that (see below), there will be the same bubbles anyway so the modification will not impact performance.\r\n\r\n```asm\r\n; begin repeat\r\nmul m, a, b ; issue ok\r\nadd r, r, m ; bubble because needs m from mul above and mul duration is 2 cycles\r\n; end repeat\r\n````", "> Actually, I believe that the throughput could increase quite a bit if the mult/div unit uses the FP port. On a mult/div instruction, it's probably more likely that the next instruction will be an ALU instruction than a FPU instruction. But I'm not sure how big of an endeavor it would be to complete this.\r\n\r\nFor CoreMark the increase would be less than 3%, but it depends of the application.\r\n\r\nAbout area:\r\n\r\nFor a configuration with both F and M, we use an existing write-back port so it is okay.\r\n\r\nFor a configuration with M, without F, today there should not be a write-back port for FPU, so the muxes in the scoreboard could be cheap. If we add one port for the multiplier, it means that the muxes are big.\r\n\r\nSo maybe the performance vs area cost should be discussed."], "type": "hardware", "design": "default_riscv"}
{"index": 115, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1096", "title": "Performance Counter CSRs in User Manual do not align with Requirements Specification", "body": "The [Performance Counters section of the Requirements Specification](https://docs.openhwgroup.org/projects/cva6-user-manual/02_cva6_requirements/cva6_requirements_specification.html#performance-counters) indicate that there should be six 64-bit performance counters (`HPM-20`) and these performance counters shall be selected by the mhpmevent3 to mhpmevent8 CSRs  (`HPM-40`).  This is contradicted by the User Manual which implies that specific performance counter functions are hardwired to specific CSRS (e.g. [L1-Icache-miss](https://docs.openhwgroup.org/projects/cva6-user-manual/01_cva6_user/CV32A6_Control_Status_Registers.html#l1-inst-cache-miss-ml1-icache-miss)).", "comments": ["@TulikaSi    COuld you help us on this specification and implementation point ?", "Hi @JeanRochCoulon and @MikeOpenHWGroup \r\nAs per the RISC V Specification (**Section 3.1.10 of Volume 2, Privileged Spec v. 20211203** ), the hardware performance monitor includes 29 no. of 64-bit event counters, **mhpmcounter3\u2013 mhpmcounter31** along with the event selector CSRs, **mhpmevent3\u2013mhpmevent31** and the same has been mentioned in the Performance Counter Section of the Requirement Specification. An issue [https://github.com/openhwgroup/cva6/issues/683]had been raised regarding the length of the performance counters and a PR has been submitted in order to comply with the length as well the implementation as per the RISCV Specification -----[https://github.com/openhwgroup/cva6/pull/1034] which can be reviewed(regarding the implementation part)but few modifications are required before merging it.\r\n\r\n", "Hi @MikeOpenHWGroup @JeanRochCoulon \r\nThe document ( https://github.com/openhwgroup/cva6/blob/master/docs/01_cva6_user/CSR_Performance_Counters.rst ) clearly explains about the perf counters but the **CV32A6_Control_status_Register_rst doc** ( https://github.com/openhwgroup/cva6/blob/master/docs/01_cva6_user/CV32A6_Control_Status_Registers.rst ) needs to be modified to comply with the implementation so that it does not create a confusion."], "type": "hardware", "design": "default_riscv"}
{"index": 116, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1091", "title": "[BUG] Under some microarchitectural circumstances, NAN conversion from simple to double precision gives wrong result", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nHi there!\r\n\r\nI've detected a bug in CVA6, potentially in CVFPU but I'm not certain so I post it here. Please let me know if this is a CVFPU bug, and I can move it there.\r\n\r\n## Brief bug description\r\n\r\nA conversion of nan from simple to double may set a lot of bits in the mantissa, unexpectedly, under specific microarchitectural conditions.\r\n\r\n## Example instance 1\r\n\r\nIn this instance, we convert the single-precision `0xffffffffff800000` using `fcvt.d.s`.\r\nWe expect to get `0xfff0000000000000` as a result, but under the circumstances induced in the very simple ELF, we get `0xffefffffffffffff`. I confirmed the expected result with spike, and in the snippet further below in CVA6.\r\n\r\n[Here is the ELF and waveforms of the bug.](https://github.com/openhwgroup/cva6/files/10891811/nancvt.zip)\r\nA symptom of the bug is the first write to address `0x18`, which essentially writes the result of the conversion.\r\n\r\nHere you can observe that the value dumped is erroneous.\r\n\r\n![waveform](https://user-images.githubusercontent.com/28906668/222960331-1a743cca-73b2-4583-bf87-05c41c0bfa10.png)\r\n\r\n## Example instance 2\r\n\r\nIn this instance, we convert the single-precision `0xffffffff7f800000` using `fcvt.d.s`.\r\nWe expect to get `0x7ff0000000000000` as a result, but under the circumstances induced in the very simple ELF, we get `0x7fefffffffffffff`. I confirmed the expected result with spike, and in the snippet further below in CVA6.\r\n\r\n[Here is the ELF and waveforms of the bug.](https://github.com/openhwgroup/cva6/files/10891843/nancvt2.zip)\r\nA symptom of the bug is the sixth write to address `0x18`, which essentially writes the result of the conversion.\r\n\r\n![waveform](https://user-images.githubusercontent.com/28906668/222961034-a5056037-d19e-4adb-b8b7-4991e202916f.png)\r\n\r\n## Example instance that runs correctly\r\n\r\nInterestingly, performing the conversion out of context works, for example this snippet executes apparently correctly. It is similar if we replace the values with the values of the second instance.\r\n\r\n```\r\n  .section \".text.init\",\"ax\",@progbits\r\n  .globl _start\r\n  .align 2\r\n_start:\r\n\r\n  # Enable the FPU\r\n  li t0, 0x2000\r\n  csrs mstatus, t0\r\n  csrw\tfcsr,x0\r\n\r\n  la t0, .fdata0\r\n  fld fa5, (t0)\r\n\r\n  fcvt.d.s ft0, fa5\r\n\r\n  li t0, 0x18\r\n  fsd ft0, (t0)\r\n\r\n  sw x0, 0(x0)\r\n\r\ninfinite_loop:\r\n  j infinite_loop\r\n\r\n.section \".fdata0\",\"ax\",@progbits\r\n  .8byte 0xffffffffff800000\r\n```\r\n\r\nTherefore I deduce that this is conditioned by some microarchitectural effects (maybe branch prediction but I am not certain).\r\n\r\nThanks!\r\nFlavien", "comments": ["Hi @flaviens, thanks for this issue!  Can you close this issue and re-post it to the [CVFPU repo](https://github.com/openhwgroup/cvfpu)?  As you may know, the CVA6 team is working to verify v5.0.0 which does not support the FD ISA.  Of course a future release of CVA6 _will_ support FD and will use the CVFPU for that.\r\n\r\nIt is important to get this issue in the CVFPU repo as the CV32E40P v2.0.0 integrates CVFU and that project will need a fully verified floating point unit much eariler than CVA6.", "Hi @MikeOpenHWGroup , thank you for your response, I'll do this! I initially decided to post here because the bug symptom _may_ result from a CVA6-specific microarchitectural condition. Will keep it in mind in case another design could not reproduce these specific instance."], "type": "hardware", "design": "default_riscv"}
{"index": 117, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1071", "title": "[BUG] Ariane incorrectly treats NaNs as zeros for simple precision floating-point arithmetics", "body": "I discovered that Ariane unexpectedly sets the NV (invalid operation) when we call `fdiv.s` on floating-point operands that have the 32 lower bits as zeros but are NaNs.\r\n\r\nExample snippet to reproduce:\r\n```\r\n  .section \".text.init\",\"ax\",@progbits\r\n  .globl _start\r\n  .align 2\r\n_start:\r\n\r\n  # Enable the FPU\r\n  li t0, 0x2000\r\n  csrs mstatus, t0\r\n  csrw\tfcsr,x0\r\n\r\n  la t0, .fdata0\r\n  la t1, .fdata1\r\n  fld ft0, (t0)\r\n  fld ft1, (t1)\r\n\r\n  fdiv.s ft2, ft0, ft1\r\n  csrr t2, fflags\r\n\r\ninfinite_loop:\r\n  j infinite_loop\r\n\r\n.section \".fdata0\",\"ax\",@progbits\r\n  .8byte 0x49a3e80e00000000\r\n.section \".fdata1\",\"ax\",@progbits\r\n  .8byte 0xa81ad47700000000\r\n```\r\n\r\nFrom spike, fflags should be clear, but Ariane sets fflags=0x10, which corresponds to NV.\r\nLet me know if I can help debug that.\r\n\r\n**Note:** this may be an issue proper to the FPU, not yet entirely sure.\r\n\r\nThanks!\r\nFlavien", "comments": ["Hi @flaviens, this is a known issue with a complex history.  As you may know, the CVA6 is using a version of the PULP Platform FPNEW floating point unit.  This IP has been transfered to OpenHW and rebranded as [CVFPU](https://github.com/openhwgroup/cvfpu).  This IP is undergoing several updates and full verification as part of the [CV32E40P](https://github.com/openhwgroup/cv32e40p) v2 project.\r\n\r\nThe CVA6 will integrate CVFPU once it has been fully verified in the E40P project.  However, there is currently no timeline for this as the current CVA6 device under development (CV32A6) does not support the F and D ISAs.", "Hi @MikeOpenHWGroup, thank you for your prompt reply! You say it is a known issue but I could not find a mention of it anywhere. Can you please show where it is documented?\r\nThanks!", "Hello @flaviens   CVA6 FPU has just been updated !  I hope this has solved the issue. Can I ask you to verify it and close the issue if it is ok on your side ? ", "Hi @JeanRochCoulon thanks for the notification! What improvements do you expect: just this issue or all pending FPU issues to be fixed?", "Hello @flaviens,   \r\nConcerning the current issue, if it is fixed, do not hesitate to close. \r\nOf course, it would be better to challenge all the FPU functionalities. So, if you find other bugs, I would encourage you to enter new github issues. Thanks for your feedback.", "Thank you for your response! \r\nDoes the FPU update intend to fix all the yet reported FPU issues in fpnew (e.g., but not limited to [this one](https://github.com/openhwgroup/cvfpu/issues/76))?\r\nThanks!", "I close this one but [this issue](https://github.com/openhwgroup/cva6/issues/1192) shares similarities"], "type": "hardware", "design": "default_riscv"}
{"index": 118, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1060", "title": "Incorrect documentation of mtvec CSR in user manual", "body": "### Is there an existing CVA6 bug for this?\r\n\r\n- [X] I have searched the existing bug issues\r\n\r\n### Bug Description\r\n\r\nThis issue points out **mtvec** documentation. \r\nIn CVA6 CSR documentation, Mode field access for **mtvec** is mentioned as RW as shown below.\r\n<html>\r\n<body>\r\n<!--StartFragment-->\r\n\r\nBits | Name | Display Name | Access Type | Reset\r\n-- | -- | -- | -- | --\r\n[31:2] | BASE | \u00a0 | RW | 0b0\r\n[1:0] | MODE | \u00a0 | RW | 0b0\r\n\r\n<!--EndFragment-->\r\n</body>\r\n</html>\r\nThe access type for the Mode field should be as mentioned below. \r\n\r\nAs per the CVA6 for mtvec CSR mode field we have two implementation options  i.e Direct Mode(00) and vector Mode (01).so the mode[1] bit is fixed to 0 making this bit to RO.\r\n\r\n\r\n<html>\r\n<body>\r\n<!--StartFragment-->\r\n\r\n\r\nBits | Mode | Description\r\n-- | -- | -- |\r\n1 | RO | MODE[1]: always 0\r\n0 | RW | MODE[0]: 0 = direct mode, 1 = vectored mode.\r\n\r\n<!--EndFragment-->\r\n</body>\r\n</html>\r\n\r\n", "comments": ["Thank you @spidugu444 for this GitHub issue.\r\nAs it is connected with the previous discussion involving @ASintzoff and @MikeOpenHWGroup about https://github.com/openhwgroup/cva6/pull/1049, I prefer to have it assigned to Andr\u00e9", "Hi @JeanRochCoulon.  It is good that you have an opinion about who to assign this to.  In such cases, please feel free to change the Assignee.\r\n\r\nHi @spidugu444.  Please ensure that Component and Status flags are added to each Issue."], "type": "hardware", "design": "default_riscv"}
{"index": 119, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1058", "title": "[BUG] <Wrong assignment of X_NUM_RS>", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nHello,\r\nI notice that in the cvxif.pkg, the **X_NUM_RS** is assign by  **NR_RGPR_PORTS** (a constant in the ariane_pkg.sv), hence the **X_NUM_RS**, can't change only if it changed in the ariane_pg.sv.\r\nSo what do you think about this ? ", "comments": ["Hello, \r\nI don't think it is a bug. It is a choice I made when implementing CVXIF in order to not increase size of the register file when cvxif does not need NR_RGPR_PORTS=3. Like a lot of parameters in ariane_pkg.sv, you can modify it. It takes 2 or 3 for value. and both parameters together to avoid miss combination. \r\nMaybe it is not the best of implementation, feel free to recommend a better one if you think it is necessary.", "The problem is that if I wanna execute a test with 3 source registers, i should change in the **araine_pkg**, it's like i change in the RTL, and i don't think it's practical.", "Yes if you want to use 3 source registers, you have to change the RTL because it is not the default configuration of CVA6.", "Hi @Gchauvon, what is the proper value of `NR_RGPR_PORTS` for the CV32A6 v5.0.0?", "It's `NR_RGPR_PORTS=2`", "We could add this parameters in the config_pkg. It can be part of CVA6 parametrization."], "type": "hardware", "design": "default_riscv"}
{"index": 120, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1049", "title": "Fix for MISA CSR spec for CV32A6", "body": "This PR addresses issue #1048.\r\n\r\nNote: I am not sure whether to merge this into `master` or `cv32a6_v5.0.0`.  My suggestion is the master branch since this PR updates the CV32E6 User Manual only and the master branch is used to by ReadTheDocs to publish CVA6 documentation.", "comments": ["LGTM. @ASintzoff Can you tell me if PR is OK to you ?", "> LGTM. @ASintzoff Can you tell me if PR is OK to you ?\r\n\r\nI'm wondering if RO wording is the appropriate one.\r\nThere is a difference between RO (read-only) CSR and WARL (write any values, read legal values). Write access to RO CSR raises an illegal instruction exceptions but write access to WARL does not.\r\nAs the behaviour is different, it could be useful to highlight the difference.\r\n\r\nBTW, was the file generated by Register Manager? Does it mean the generation is only for the first version?", "Good points @ASintzoff!\r\n\r\n> I'm wondering if RO wording is the appropriate one. There is a difference between RO (read-only) CSR and WARL (write any values, read legal values).\r\n\r\nThe access mode behaviours in the Privileged Specification define what software does, not hardware. \r\n\r\n> Write access to RO CSR raises an illegal instruction exceptions but write access to WARL does not. As the behaviour is different, it could be useful to highlight the difference.\r\n\r\nThe Privilege Spec says the hardware _may_ raise an illegal exception, but I do not believe CVA6 does this.  If I am right, then for the MISA an RO CSR is a legal way to implement a WARL CSR.  See #1053.\r\n\r\n> BTW, was the file generated by Register Manager? Does it mean the generation is only for the first version?\r\n\r\nWe have a choice.  We can either manually update the RST files (see #1049), or we can update the source input to Register Manager and regenerate the RST.", "> Good points @ASintzoff!\r\n> \r\n> > I'm wondering if RO wording is the appropriate one. There is a difference between RO (read-only) CSR and WARL (write any values, read legal values).\r\n> \r\n> The access mode behaviours in the Privileged Specification define what software does, not hardware.\r\n> \r\n> > Write access to RO CSR raises an illegal instruction exceptions but write access to WARL does not. As the behaviour is different, it could be useful to highlight the difference.\r\n> \r\n> The Privilege Spec says the hardware _may_ raise an illegal exception, but I do not believe CVA6 does this. If I am right, then for the MISA an RO CSR is a legal way to implement a WARL CSR. See #1053.\r\n\r\nI agree that writing to `misa` does not raise any exception as it is a WARL register. From Privilege Spec: `Implementations will not raise an exception on writes of unsupported values to a WARL field.`\r\n\r\nNevertheless, do we need to distinguish the following behaviours:\r\n- exception raised when write to read-only (as in RISC-V privilege spec) register. `Attempts to access a\r\nCSR without appropriate privilege level or to write a read-only register also raise illegal instruction\r\nexceptions.`\r\n- silent execution when write to WARL register\r\n\r\n> > BTW, was the file generated by Register Manager? Does it mean the generation is only for the first version?\r\n> \r\n> We have a choice. We can either manually update the RST files (see #1049), or we can update the source input to Register Manager and regenerate the RST.\r\n\r\nManually updating the RST file is fine for me.", "Yes, very good point! It will help verification to specify whether exception is generated (or not). But in that case, all registers are concerned by this modification, not only MISA CSR. The CSR spec is to be aligned on RISC-V specification and need to contain an explanation about the RO and WARL meanings.\r\nAgree to modify the rst file.", "@MikeOpenHWGroup As the current agreed stragtegy is to modify the IP-XACT version to generate the specification (rst file), this PR should be updated. @yanicasa what do you suggest as methodology to modify the IP-XACT file ? ", "@frikhaAziz This PR would like to modify the CSR specification. As this need to be done in IP-XACT, could you propose an PR to fix the spec.", "Hello @mike,  #1330 should have superseeded this PR. If you agree, can you close it ?", "Closing as #1330 does indeed supersede this PR."], "type": "hardware", "design": "default_riscv"}
{"index": 121, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1029", "title": "[BUG] std_cache_subsystem: AXI w_valid waits for aw_ready", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nOn page A3-45 (AXI3 write transaction dependencies), the [AXI spec](https://developer.arm.com/documentation/ihi0022/hc) says: \"The Manager must not wait for the Subordinate to assert AWREADY or WREADY before asserting AWVALID or WVALID.\"\r\n\r\nIn core/cache_subsystem/std_cache_subsystem.sv, this seems to be violated: A new W channel element is pushed to i_fifo_w_channel only when aw_valid and aw_ready. As long as aw_ready is not asserted, no element is pushed to the FIFO. w_select_arbiter remains zero and i_stream_mux_w drives axi_req_o.w_valid low.\r\n\r\nWhen an AXI subordinate waits for both aw_valid and w_valid before asserting aw_ready and w_ready, as it is allowed to, the AXI bus deadlocks. To reproduce: Wire up [axi_to_mem](https://github.com/pulp-platform/axi) directly to the cva6 module configured with std_cache_subsystem. Deadlock occurs on first store. Inserting an axi_cut instance between cva6 and axi_to_mem resolves the deadlock.\r\n\r\nThe condition `.push_i ( axi_req_o.aw_valid & axi_resp_i.aw_ready )` seems logically important for how std_cache_subsystem works. As I have little knowlege about the module, I am not sure how the problem could be resolved or whether this is a user problem.", "comments": ["Hi @JeanRochCoulon, I am not sure who is best positioned to address this issue, so I assigned it to you.  Please find the appropriate victim.", "Hi @AEzzejjari   It seems you are the best positioned to answer this GitHub issue. I will assign it to you.", "Hello, In this case, the FIFO is not an intermediate between the CVA6 and the Subordinate. It is a back up to store all the requests sent by the CVA6 and accepted by the Subordinate, in order to check that the response sent by the Subordinate in the write response channel is compliant with the request.\r\n\r\nWe can test the case when CVA6 performs a request and aw_ready/w_ready = 0 with the AXI agent. You just have to change the attribute drv_slv_mode in cfg class with UVMA_AXI_DRV_SLV_MODE_RANDOM_LATENCY.\r\n", "> Hello, In this case, the FIFO is not an intermediate between the CVA6 and the Subordinate. It is a back up to store all the requests sent by the CVA6 and accepted by the Subordinate, in order to check that the response sent by the Subordinate in the write response channel is compliant with the request.\r\n\r\nIs this about i_fifo_w_channel? It generates the two-bit w_select_fifo signal, which to me does not seem related to protocol compliance checking.\r\n\r\n> We can test the case when CVA6 performs a request and aw_ready/w_ready = 0 with the AXI agent. You just have to change the attribute drv_slv_mode in cfg class with UVMA_AXI_DRV_SLV_MODE_RANDOM_LATENCY.\r\n\r\nI guess this is about test coverage, can I help there somehow?", "> Is this about i_fifo_w_channel? It generates the two-bit w_select_fifo signal, which to me does not seem related to protocol compliance checking.\r\n\r\nYes, it's not about checking protocol compliance or when we can assert AWVALID or WVALID. It's just about having a traceability of the accepted transaction if you see the input data and the output data is just an ID. This FIFO allows us to verify that we have the right response to a request.\r\n\r\n> I guess this is about test coverage, can I help there somehow?\r\n\r\nThanks, but if you want to make sure that there is no error and the manager does not wait for the subordinate to assert AWREADY or WREADY before asserting AWVALID or WVALID. You can use the AXI agent, which can randomize ready-to-valid latency. If you want to do this, send me an email so I can show you how.  \r\n", "I am not sure whether an agent with randomized latency triggers the problem, since it is about dependencies between the channels. Unfortunately, I currently do not have the time to try it out or look deeper into this. I guess it is up to others to decide whether this issue is serious enough to warrant more work."], "type": "hardware", "design": "default_riscv"}
{"index": 122, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1026", "title": "[BUG] common_cell's FPU ", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nTwo common_cell submodules are used in CVA6 :\r\n- common_cell dedicated to FPU \r\n- common_cell dedicated to CVA6 and testharness (out of FPU)\r\n\r\nBut Flist uses only the common_cell dedicated to CVA6 and testharness. Common_cell dedicated to FPU is not used.\r\n\r\n", "comments": ["Hi @zarubaf    You proposed several days ago to use only one common_cell for cva6 and FPU. This issue will be closed by #1102 PR.", "Closed by #1102 "], "type": "hardware", "design": "default_riscv"}
{"index": 123, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/997", "title": "CV32A6 Design Document includes floating point CSRs", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nThe [register description](https://docs.openhwgroup.org/projects/cva6-user-manual/03_cv32a6_design/source/cv32a6_csr.html#register-descriptions) section of the CV32A6 Design Document lists a set of RV32F floating point CSRs.   As far as I am aware, the CV32A6 does not support floating point, so these registers should not exist and therefore not be part of the Design Document.", "comments": ["In CV32A6 Design Document there are group of trigger registers which has not been implemented in CVA6 RTL.\r\nAs these registers has not been implemented therefore these will not to be part of the Design Document.\r\nPlease find the details of trigger registers as mentioned below.\r\n\r\n<html xmlns:v=\"urn:schemas-microsoft-com:vml\"\r\nxmlns:o=\"urn:schemas-microsoft-com:office:office\"\r\nxmlns:x=\"urn:schemas-microsoft-com:office:excel\"\r\nxmlns=\"http://www.w3.org/TR/REC-html40\">\r\n\r\n<head>\r\n\r\n<meta name=ProgId content=Excel.Sheet>\r\n<meta name=Generator content=\"Microsoft Excel 15\">\r\n<link id=Main-File rel=Main-File\r\nhref=\"file:///D:/Users/T0268396/AppData/Local/Temp/msohtmlclip1/01/clip.htm\">\r\n<link rel=File-List\r\nhref=\"file:///D:/Users/T0268396/AppData/Local/Temp/msohtmlclip1/01/clip_filelist.xml\">\r\n\r\n<!--table\r\n\t{mso-displayed-decimal-separator:\"\\.\";\r\n\tmso-displayed-thousand-separator:\"\\,\";}\r\n@page\r\n\t{margin:.75in .7in .75in .7in;\r\n\tmso-header-margin:.3in;\r\n\tmso-footer-margin:.3in;}\r\ntr\r\n\t{mso-height-source:auto;}\r\ncol\r\n\t{mso-width-source:auto;}\r\nbr\r\n\t{mso-data-placement:same-cell;}\r\ntd\r\n\t{padding-top:1px;\r\n\tpadding-right:1px;\r\n\tpadding-left:1px;\r\n\tmso-ignore:padding;\r\n\tcolor:black;\r\n\tfont-size:11.0pt;\r\n\tfont-weight:400;\r\n\tfont-style:normal;\r\n\ttext-decoration:none;\r\n\tfont-family:Calibri, sans-serif;\r\n\tmso-font-charset:0;\r\n\tmso-number-format:General;\r\n\ttext-align:general;\r\n\tvertical-align:bottom;\r\n\tborder:none;\r\n\tmso-background-source:auto;\r\n\tmso-pattern:auto;\r\n\tmso-protection:locked visible;\r\n\twhite-space:nowrap;\r\n\tmso-rotate:0;}\r\n.xl65\r\n\t{color:#44546A;\r\n\tfont-family:Arial, sans-serif;\r\n\tmso-font-charset:0;\r\n\ttext-align:center;\r\n\tvertical-align:middle;\r\n\tborder:.5pt solid windowtext;\r\n\tbackground:#F3F6F6;\r\n\tmso-pattern:black none;}\r\n.xl66\r\n\t{color:#44546A;\r\n\tfont-family:Arial, sans-serif;\r\n\tmso-font-charset:0;\r\n\ttext-align:center;\r\n\tvertical-align:middle;\r\n\tborder:.5pt solid windowtext;\r\n\tbackground:#FCFCFC;\r\n\tmso-pattern:black none;}\r\n.xl67\r\n\t{color:#0070C0;\r\n\tfont-size:13.0pt;\r\n\tfont-family:Consolas, monospace;\r\n\tmso-font-charset:0;\r\n\ttext-align:center;\r\n\tvertical-align:middle;\r\n\tborder:.5pt solid windowtext;\r\n\tbackground:#F3F6F6;\r\n\tmso-pattern:black none;}\r\n.xl68\r\n\t{color:#0070C0;\r\n\tfont-size:13.0pt;\r\n\tfont-family:Consolas, monospace;\r\n\tmso-font-charset:0;\r\n\ttext-align:center;\r\n\tvertical-align:middle;\r\n\tborder:.5pt solid windowtext;\r\n\tbackground:#FCFCFC;\r\n\tmso-pattern:black none;}\r\n.xl69\r\n\t{color:#0070C0;\r\n\tfont-size:13.0pt;}\r\n-->\r\n\r\n</head>\r\n\r\n<body link=\"#0563C1\" vlink=\"#954F72\">\r\n\r\n\r\n\r\ntselect | 0x7A0\r\n-- | --\r\ntdata1 | 0x7A1\r\ntdata2 | 0x7A2\r\ntdata3 | 0x7A3\r\ntinfo | 0x7A4\r\n\r\n\r\n\r\n</body>\r\n\r\n</html>\r\n", "The FPU and trigger CSrs have been removed from Design Document, please refer to :\r\nhttps://docs.openhwgroup.org/projects/cva6-user-manual/04_cv32a6_design/source/csr_list.html "], "type": "hardware", "design": "default_riscv"}
{"index": 124, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/955", "title": "[BUG] <title>The linux image in SD card cannot boot on 7k410t board, I don't know the reason", "body": "### Is there an existing CVA6 bug for this?\n\n- [X] I have searched the existing bug issues\n\n### Bug Description\n\nDear,\r\n      hello, I'm a new user of FPGA.Now I want to achieve this cva6 on my FPGA board, which has a chip named kintex7 - 7k410tffg900-2. However, after download bit file, the screen cannot display anything.So I want to get some suggestions,thanks !\r\n     Here are the flows I did:\r\n     (1) changed the Makefile in corev_apu/. I changed the part name to 7k410tffg900-2.\r\n     (2) Delete the ethernet .(in fact, just set Inclthernet = 0 )\r\n     (2) change the ip core .Then I comment some scripts like this. and I changed the xlnx_mig_7_ddr3's mig_a.prj for my fpga board.\r\n![image](https://user-images.githubusercontent.com/88300259/190398170-ec2b9573-c4db-4b94-9c21-02874ee1eb92.png)\r\n     (3) make fpga. the bit file is generated successfully.\r\n\r\n     (4)SD card. follw the flow \u201cboot from sd card\u201din cva6-sdk. after install tools, I use make images to generate right images.After make flash-scard, The result is like this,\r\n![image](https://user-images.githubusercontent.com/88300259/190399533-bfac571a-5b9e-4390-bfe8-68d7e0486700.png)\r\n         Now the serial cannot display anything(fully blank),I'm really confused,could you help me please? Thank you very much!\r\n", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 125, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/1417", "title": "Mstatus bug in RISCV CVA6", "body": "Hello, @ASintzoff @JeanRochCoulon \r\nI have been using the RISCV-DV (I use VCS to compile and run the generator), to improve the Code coverage of the CVA6 Core processor, by generating tests from the RISCV-DV using a YAML description, and while trying to access the CVA6\u2019 CSRs, After a failed test, comparing the output of CVA6 with the reference model (spike), I found a mismatch between CVA6 and ref model Spike, the mismatch was in the Mstatus register, is a MXLEN-bit read/write register (64 bits for my case), formatted as shown in Figure 3.7 in (The RISC-V Instruction Set Manual Volume II: Privileged Architecture). The mstatus register keeps track of and controls the hart\u2019s current operating state.\r\n \r\nThe problem appears clearly in WPRI (Some whole read/write fields are reserved for future use. Software should ignore the values read from these fields, and should preserve the values held in these fields when writing values to other fields of the same register. For forward compatibility, implementations that do not furnish these fields must make them read-only zero. These fields are labeled WPRI in the register descriptions) field (Spike read-only zero, while CVA6 read a different value).\r\nIn some tests, we found a mismatch also in other fields, for example the UBE field, SPP and SBE.\r\nSo to reproduce the problem, I recommend use the RISCV-DV using the YAML description in cva6/dev branch, core-v-verif/cva6/sim/cva6_base_testlist.yaml (https://github.com/openhwgroup/core-v-verif/blob/cva6/dev/cva6/sim/cva6_base_testlist.yaml), adding to this list the description to reproduce the bug:  \r\n\r\n- test: Mstatus_bug\r\n  description: >\r\n    Arithmetic instruction test, with CSR instructions\r\n  gen_opts: >\r\n    +instr_cnt=500\r\n    +num_of_sub_program=0\r\n    +directed_instr_0=riscv_int_numeric_corner_stream,5\r\n    +no_fence=1\r\n    +no_data_page=1\r\n    +no_branch_jump=1\r\n    +boot_mode=m\r\n    +no_csr_instr=0\r\n    +randomize_csr=1\r\n    +enable_illegal_csr_instruction=1\r\n  iterations: 2\r\n  gen_test: riscv_instr_base_test\r\n  rtl_test: core_base_test\r\n\r\nAfter that run the RISCV-DV:\r\n\r\npython3 cva6.py --testlist=cva6_base_testlist.yaml --test Mstatus_bug --iss_yaml cva6.yaml --target cv64a6_imafdc_sv39 --iss=vcs-uvm,spike -i 10  --iss_timeout 300 (run it in core-v-verif/cva6/sim)\r\n\r\n10 iterations can be enough to found t", "comments": ["How do i assign this issue to myself?", "Hi @seriesAB, thanks for your interest in CVA6.  This is _not_ a good first issue and is not in any way related to openhwgroup/core-v-verif#1404.  I would recommend focusing on that one first.  Thanks!", "yes thank you doing that!", "Fixed by PR #1626"], "type": "hardware", "design": "default_riscv"}
{"index": 126, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/927", "title": "Possible deadlock when executing from NI memory", "body": "This bug was initially reported in #708.\r\n\r\n> Consider the following scenario while executing from nonidempotent memory:\r\n> \r\n> 1. A branch instruction is fetched => `speculative_d = 1'b1`\r\n> 2. The instruction queue is full, `replay` is asserted\r\n> 3. Once the instruction queue is `ready` again, the frontend sends a request to the icache to refetch the branch instruction\r\n> 4. The icache blocks as `dreq.spec == 1'b1` (and we do not fetch speculatively from nonidempotent memory)\r\n> 5. Deadlock\r\n\r\nI think there are several possible ways to handle this, for instance:\r\n- Clear the `speculative` register on a replay (proposed in #708)\r\n- Disallow execution from NI memory (is this RISC-V compliant? Are there cases for executing from NI memory, e.g. the debug module?)\r\n_Note: for the debug module, it might suffice to define only writes as non-idempotent and reads (including instruction fetches) as idempotent, which is possible according to the priv. spec but currently not supported by ariane._\r\n- Allow speculative instruction fetches from NI memory, possibly violating the NI requirement\r\n- Preventing replays in the first place when executing from NI memory, i.e. only fetching when the instruction queue can certainly accept an incoming instruction. For NI memory, we generally do not care about performance, and this might be the cleanest solution allowing to execute from NI memory without side effects.\r\n\r\nI'm happy to help implement one of the solutions above (or yet another)!", "comments": ["Hi @niwis.  I _think_ this issue was resolved.  Can you confirm?  If so, please close this issue.", "I don't think so. AFAIK one can still configure a memory region as executable *and* non-idempotent, and the core might still dead-lock if one does so."], "type": "hardware", "design": "default_riscv"}
{"index": 127, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/917", "title": "[Bug Report] sd bit does not update immediately", "body": "Our co-simulation framework found that the mstatus.sd field does not update immediately after mstatus.fs field is dirty.\r\n\r\nIn the following test case, we set mstatus.fs field to initial(0b01), and then execute a float-point instruction. After the float-point instruction, we read the value in mastatus. We found that cva6 successfully sets fs to dirty while sd is still zero.\r\n\r\n```\r\n[spike] core   0: 0x0000000080000148 (0x300022f3) csrr    t0, mstatus\r\n[cva6]      615ns      600 M 0000000080000148 0 300022f3 csrr           t0, mstatus\r\n[spike] core   0: 0x000000008000014c (0x00002517) auipc   a0, 0x2\r\n[cva6]      617ns      602 M 000000008000014c 0 00002517 auipc          a0, 0x2\r\n[spike] core   0: 0x0000000080000150 (0xebc53487) fld     fs1, -324(a0)\r\n[cva6]      651ns      636 M 0000000080000150 0 ebc53487 fld           fs1, -324(a0)\r\n[spike] core   0: 0x0000000080000154 (0x300022f3) csrr    t0, mstatus\r\n[error] WDATA SIM 8000000a00006080, DUT 0000000a00006080\r\n[error] check board clear 5 error\r\n```\r\n\r\nAccording to riscv-privileged specification:\r\n> The SD bit is a read-only bit that summarizes whether either the FS, VS, or XS fields signal the presence of some dirty state that will require saving extended user context to memory.\r\n\r\n[cva6-10.zip](https://github.com/openhwgroup/cva6/files/8909779/cva6-10.zip)", "comments": ["Hi @Phantom1003 , I see that this issue has not been updated in > 6 months so I am closing it.   If you are still having trouble, please open a new issue."], "type": "hardware", "design": "default_riscv"}
{"index": 128, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/901", "title": "[Bug Report] implict address truncation", "body": "Our co-simulation framework found that cva6 will truncate the address to use, specifically ignoring the highest 8 bits for pc and the highest 32 bits for load/store.\r\n\r\nLet's take the rv64mi-p-access test in riscv-test as an example. In this test case, we set the MSB of a legal address 0x00000000800001dc to 1, and then we will try to access 0x80000000800001dc.\r\n\r\n```\r\n[spike] core   0: 0x00000000800001b4 (0x000283e7) jalr    t2, t0, 0\r\n[cva6]     705ns      690 M 00000000800001b4 1 000283e7 jalr           t2, t0, 0\r\n[spike] core   0: exception trap_instruction_access_fault, epc 0x80000000800001dc\r\n[spike] core   0:           tval 0x80000000800001dc\r\n[spike] core   0: 0x0000000080000004 (0x34302f73) csrr    t5, mtval\r\n[error] PC SIM 0000000080000004, DUT 80000000800001dc\r\n[error] INSN SIM 34302f73, DUT 0ff0000f\r\n[CJ] Commit Failed\r\n[cva6]     732ns      717 M 80000000800001dc 0 0ff0000f fence   // CVA6 continues to execute \r\n```\r\n\r\nIt is obviously an illegal address, and spike throws the exception correctly, but cva6 ignores the highest 8 bits and continues to execute it as normal, because the value in 0x800001dc is 0x0ff0000f:\r\n```   \r\n>>> 800001dc:\t0ff0000f          \tfence   <<<\r\n    800001e0:\t00018063          \tbeqz\tgp,800001e0 <fail+0x4>\r\n    800001e4:\t00119193          \tslli\tgp,gp,0x1\r\n```\r\n\r\nHonestly,  we didn't expect that cva6 didn't pass riscv-tests. Truncating pc will make it much less difficult for an attacker to launch an attack using memory corruption vulnerabilities, like the [bug](https://googleprojectzero.blogspot.com/2020/12/an-ios-hacker-tries-android.html) mentioned by google's team.\r\n> The consequence of using an unaligned addition like this is that we've also corrupted the value of X1, which stores the userspace address from which to copy in the data. Instead of the upper bytes being all 0, the top byte is now nonzero. Quite fortunately, however, this isn't a problem because the kernel was compiled with support for the Top Byte Ignore (TBI) architectural feature enabled for userspace, which means that the top byte of the pointer will be ignored for the purpose of address translation by the CPU.\r\n\r\nThe truncated mechanism implicitly implements a mechanism similar to TBI, which means that an attacker only needs to modify 56 bytes to be able to tamper with the control flow of the program, and the specification also suggests:\r\n> Ordinarily, if an instruction attempts to access memory at an inaccessible address, an exception is raised for the instruction. Vacant locations in the address space are never accessible.\r\n\r\n[cva6-5.zip](https://github.com/openhwgroup/cva6/files/8834336/cva6-5.zip)\r\n\r\n> @LuminaDCIX helps reproduce the problem", "comments": ["That is a good point. Technically `0x80000000800001dc` is a legal address and the memory subsystem truncates this to the physical address length set for the system:\r\n\r\nhttps://github.com/openhwgroup/cva6/blob/909d85a56cc5ace65765a63d7ed56b7ac2026f99/core/include/riscv_pkg.sv#L41\r\n\r\nI agree that it isn't very beautiful in the way it is handled. But generally speaking that is only a problem in M-Mode where you anyway need to trust your software. In any higher privilege mode you would either set PMPs or VM to restrict access based on the entire virtual address.\r\n\r\nThe fundamental \"flaw\" is the missing PMA that indicates whether a memory region has anything present behind itself or not.", "Hi @zarubaf, what is the resolution of this issue?  It _looks_ like it will be `WontFix`.  Please confirm."], "type": "hardware", "design": "default_riscv"}
{"index": 129, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/898", "title": "[Bug Report] Incorrect *tval for ecall/ebreak", "body": "Our co-simulation framework found that the `*tval` of `ecall/ebreak` is incorrect.\r\nIn cva6, after `ecall/ebreak`, *tval will set to the machine code of the `ecall/ebreak` instruction.\r\n\r\nIn the following test case, after calling `ebreak` in s-mode, the value of `mtval` register is written to `0x100073`, which is the machine code of `ebreak` instruction.\r\n\r\n```\r\n[spike] core   0: 0x0000000080000174 (0x00100193) li      gp, 1\r\n[cva6]       664ns      649 S 0000000080000174 0 00100193 li             gp, 1\r\n[cva6]  Exception @     66500, PC: 0000000080000178, Cause: Breakpoint, tval: 0000000000100073\r\n[spike] core   0: 0x0000000080000178 (0x00100073) ebreak\r\n[spike] core   0: exception trap_breakpoint, epc 0x0000000080000178\r\n[spike] core   0:           tval 0x0000000080000178\r\n... /* in handler */\r\n[spike] core   0: 0x0000000080000190 (0x343022f3) csrr    t0, mtval\r\n[error] WDATA SIM 0000000080000178, DUT 0000000000100073\r\n[error] check board clear 5 error\r\n[CJ]  integer register Judge Failed\r\n```\r\n\r\nriscv-priviledged P41 \uff1aIf `mtval` is written with a nonzero value when a breakpoint, address-misaligned, access-fault, or page-fault exception occurs on an instruction fetch, load, or store, then mtval will contain the faulting virtual address.\r\nAccording to specifications, `mtval` should be the faulting address (or zero).\r\n\r\nIssue [448](https://github.com/openhwgroup/cva6/issues/448) tests the value in `stval` of `ecall` from user mode, our verification framework further discovered that `ebreak` also has the same bug, and both of them could be triggered under **any privilege modes**.\r\n\r\nebreak testcase: [cva6-1.zip](https://github.com/openhwgroup/cva6/files/8832584/cva6-1.zip)\r\necall testcase: [cva6-2.zip](https://github.com/openhwgroup/cva6/files/8832585/cva6-2.zip)\r\n> @LuminaDCIX helps reproduce the problem", "comments": ["Indeed, the instruction bits are the default case for every instruction. Confirming that we are not complying.\r\n\r\n`ebreak`/`ecall` should be able to be triggered from any privilege level, no? How would a syscall/debug call work otherwise from user space?", "Thanks, the point we wanted to confirm was the mismatched *tval.\r\nAnd sorry for the confusion in my description, we wanted to point out that the ecall/ebreak triggered in any privileged mode will produce a mismatched value, not just the case in user mode as mentioned in 448.\r\n", "Hi @JeanRochCoulon, this issue appears to be a bug in the CVA6 RTL and so I am assigning it to you - please move to the appropriate engineer for a resolution.", "This issue should be covered by step1 verification. But I have a doubt. @ASintzoff can you give visibility on it ?"], "type": "hardware", "design": "default_riscv"}
{"index": 130, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/897", "title": "CVXIF issue_valid and commit_valid are always sent at the same clk cycle", "body": "CVA6 always send the issue transaction and the commit transaction at the same clk cycle. It's allowed by the cvxif Spec, but if it is hard coded it may cause problems in some cases where cva6 needs to set the commit_kill (currently CVA6 never raise the commit_kill signal).", "comments": ["Hi @ZElkacimi, this issue is more than 6 months old and has not received a comment.  Can you work with @JeanRochCoulon to identify the right person to move this issue forward?", "Feature not supported. A fix might come with an update implementation of the CVXIF which is still in development."], "type": "hardware", "design": "default_riscv"}
{"index": 131, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/896", "title": "CVXIF result_ready is always 1", "body": "CVA6 always sets the signal result_ready to 1.", "comments": ["Hi @ZElkacimi, this issue is more than 6 months old and has not received any updates.  Pleas work with @JeanRochCoulon to find the right person to move this along.", "Not a bug, this is the desired behaviour of the CVA6."], "type": "hardware", "design": "default_riscv"}
{"index": 132, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/895", "title": "CVA6 do not support cvxif dualwrite/dualread", "body": "CVA6 do not support dualread and dualwrite from a Coprocessor.\r\n\r\nAlso, related to dualwrite: It is mentioned in the cvxif spec, that **we** is 2 bits wide when XLEN = 32 and X_RFW_WIDTH = 64, and 1 bit wide otherwise. If **we** is 2 bits wide, then we[1] is only allowed to be 1 if we[0] is 1 as well (i.e. for dual writeback). The picture below, from cvxif spec, shows how it should be declared:\r\n\r\n![image](https://user-images.githubusercontent.com/96719191/171390075-cfc2128f-189a-47f8-8045-771c4eb55753.png)\r\n\r\nWhile in cva6, at cvxif_pkg.sv, the **we** signal is declared as follow: \r\n![image](https://user-images.githubusercontent.com/96719191/171390334-cb1fe6e3-e8d5-453c-8138-270f2ac066d9.png)\r\n\r\nWe can notice two issues here, the fact that **we** is not declared correctly, and that, definitely, cva6 currently do not support dualwrite from a coprocessor.\r\n", "comments": ["Hi @ZElkacimi, this issue is more than 6 months old and has not received any updates. Pleas work with @JeanRochCoulon to find the right person to move this along.", "Feature not supported. Package should be updated to respect the specification more closely.\r\nSpecification is in development so a fix might come with an updated implementation of CVXIF"], "type": "hardware", "design": "default_riscv"}
{"index": 133, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/891", "title": "CVA6 never raise the cvxif commit_kill signal", "body": "If commit_valid is 1 and commit_kill is 0, then the core guarantees that the offloaded instruction (id) is no longer speculative, will not get killed (e.g. due to misspeculation or an exception in a preceding instruction), and is allowed to be committed. If commit_valid is 1 and commit_kill is 1, then the offloaded instruction (id) shall be killed in the coprocessor and the coprocessor must guarantee that the related instruction does/did not change architectural state.\r\n\r\nIn all tested cvxif custom instructions, cva6 have never raised the commit_kill signal, even when it has an exception in a preceding instruction.", "comments": ["Hi @ZElkacimi, this issue is more than 6 months old and has not received any updates. Pleas work with @JeanRochCoulon to find the right person to move this along.", "Feature not supported. Not a bug."], "type": "hardware", "design": "default_riscv"}
{"index": 134, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/887", "title": "CVXIF feature missing: wait for the result of the instruction that raise the issue resp.exc signal", "body": "CPU shall wait for the result of an instruction that raises the issue_resp.exc=1 signal (by the coprocessor), because it can then no longer retire (or commit via the commit interface) any younger instruction before it is known if the possible exception in the coprocessor actually happened or not, which will only be known at the corresponding result handshake (result.exc).\r\nThat is the easiest implementation; otherwise CPU might need to unroll/undo instructions that should not have been executed.\r\n", "comments": ["Hi @ZElkacimi, this issue is more than 6 months old and has not received any updates. Please work with @JeanRochCoulon to find the right person to move this along.", "Still relevant"], "type": "hardware", "design": "default_riscv"}
{"index": 135, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/884", "title": "[Bug Report] Out of bound array access", "body": "Hi,\r\n\r\nCVA6 RTL is returning unknown value (\"xxxxxxxx\") when reading the value of MHPMCOUNTER30. This is happening because the csr reg data (```csr_rdata```) is being read from ``perf_counter_d`` array in the perf_counters.sv module with an array index outside its range. The range of ``perf_counter_d`` is [riscv::CSR_MIF_EMPTY : riscv::CSR_ML1_ICACHE_MISS] (line:46 from perf_counter.sv file),  but in line: 282 of csv_regfile.sv we are using the array to access array index  riscv::CSR_MHPM_COUNTER_30, which is greater than the range of [riscv::CSR_MIF_EMPTY : riscv::CSR_ML1_ICACHE_MISS]. \r\n\r\nPlease find attached the triggering input mem file, spike_trace_log, and cva6_trace_log. We can see from the line:83 of cva6 trace log that the read data is ``xxxxxxxx``\r\n![image](https://user-images.githubusercontent.com/79608200/170143824-8a519bdf-ccc3-4126-9a81-790e50020b83.png)\r\n\r\n[outofrange.zip](https://github.com/openhwgroup/cva6/files/8766647/outofrange.zip)\r\n\r\n", "comments": ["Hi @JeanRochCoulon and @yanicasa , this issue is more than 7 months old and has not received any updates. It looks like an important issue to me. It could be that this issue has been already resolved with the latest updates to the Tracer.\r\n", "Hello @TulikaSi   This GitHub issue is related to perf counters. As you are modifying the perf counters, maybe the bug will be naturally removed. If it is not the case, can you fix it.", "@MikeOpenHWGroup   I (re)assigned you this GitHub Issue because Tulika does not appear in the assignee list. Do we need to add her to the project list ?", "> Hello @TulikaSi This GitHub issue is related to perf counters. As you are modifying the perf counters, maybe the bug will be naturally removed. If it is not the case, can you fix it.\r\n\r\nHi @JeanRochCoulon the hardware performance monitor includes 29 number of  64-bit event counters, mhpmcounter3\u2013\r\nmhpmcounter31 but in accordance to the requirement specification [https://github.com/openhwgroup/cva6/blob/master/docs/02_cva6_requirements/cva6_requirements_specification.rst#performance-counters](url) the implementation shall take into account only six generic 64-bit performance counters  **mhpmcounter3 to mhpmcounter8**  including their upper 32 bits counterparts **mhpmcounter3h to mhpmcounter8h**. So I believe after the  modification of the performance counter, the RTL can be made to return read-only 0 for unimplemented counters.", "Hi @JeanRochCoulon \r\nSince the performance counters have been modified, this issue now no longer exists as all the mhpmcounters have been implemented.\r\nWe can close this issue.", "@chenc6  If you are agree with @TulikaSi status, can you close the issue ? ", "Sure, thank you for letting me know. "], "type": "hardware", "design": "default_riscv"}
{"index": 136, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/881", "title": "[Bug Report] Issue when randomizing the CVXIF issue_ready signal", "body": "In the cvxif Spec, we have the following: \r\n-\tThe transaction signaled via issue_req and issue_resp is accepted when issue_valid and issue_ready are both 1. \r\n-\tA CPU is allowed to retract its issue request transaction before it is accepted with issue_ready = 1 ...\r\n\r\nSo, when the cpu retract the request before issue_ready=1, it should not wait for the result of the corresponding transaction, else, the transaction should remain stable until it\u2019s accepted with issue_ready=1.\r\n\r\nFor CVA6, When the cvxif agent randomize the issue_ready, in the case where issue_ready=0 && issue_valid=1, we notice that CVA6, retract its issue request before the issue_ready become 1. Yet, cva6 waits for the result of this transaction.\r\n\r\nTo reproduce the issue, in the config of the agent (uma_cvxif_cfg), change the value of\r\n ready_mode  from UVMA_CVXIF_ISSUE_READY_FIX; to  UVMA_CVXIF_ISSUE_READY_RANDOMIZED;\r\nand run any test (with core-v-verif) offloading many instructions to meet the case where issue_ready=0 && issue_valid=1.\r\n\r\nNote: one of the possible cases where this issue may present is when the Coprocessor is connected to many CPUs.\r\n", "comments": ["Hi @ZElkacimi, this issue is more than 7 months old and has not received any updates. It looks like an important issue to me. Please work with @JeanRochCoulon to assign the right person to move this along.\r\n\r\n", "Won't fix for this implementation of CVXIF. CVXIF specification is in development a fix might come with an updated implementation of the interface."], "type": "hardware", "design": "default_riscv"}
{"index": 137, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/880", "title": "[Bug Report] CPU mode is not provided to the CVXIF interface", "body": "When executing a simple test offloading a cvxif instruction (example: with core-v-verif, use the following command to execute cvxif_multi.S test; `python3 cva6.py --testlist=../tests/testlist_cvxif.yaml --test cvxif_multi  --iss_yaml cva6.yaml --target cv64a6_imafdc_sv39 --iss=vcs-uvm`), I notice at the log file that cva6 mode is 3 (machine mode).\r\nFollowing is a snippet of the csv output file:\r\n![image](https://user-images.githubusercontent.com/96719191/169838991-49444aea-d471-4c3b-82c3-6e1d235b5325.png)\r\n\r\n\r\nWhile in the message printed by the agent\u2019s monitor, the mode offloaded by the cvxif interface (issue_req.mode) is always 0.\r\nIn addition, Looking at the rtl code (cvxif_fu module), mode signal is never assigned.\r\n", "comments": ["Hi @ZElkacimi, this issue is more than 7 months old and has not received any updates. It looks like an important issue to me. Please work with @JeanRochCoulon to assign the right person to move this along.", "This issue has been fixed by PR #1298"], "type": "hardware", "design": "default_riscv"}
{"index": 138, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/879", "title": "[Bug Report] Issue with memory access", "body": "Hi,\r\nWe found that cva6 allows LOAD instructions to load value from an address that is outside the DRAM space. According to RISC-V Unprivileged ISA V20190608, page 7, \"if an instruction attempts to access memory at an inaccessible address, an exception is raised for the instruction. Vacant locations in the address space are never accessible\". However, cva6 did not throw an exception for this case.\r\nWe have the triggering test case (.mem file), the RTL trace log, and the spike trace log attached below. We can see that we are trying to load from an address outside DRAM space to register x10 (lbu  a0, -302(sp)). CVA6 is not throwing any exception for this instruction whereas spike is throwing load access fault exception.\r\n\r\nIs this a bug in cva6?\r\n[bug_report.zip](https://github.com/openhwgroup/cva6/files/8749872/bug_report.zip)\r\n", "comments": ["I wouldn't say a bug, but rather an unsupported feature. Initially, there was some push to get this feature in but I think that never came to fruition. Adding @JeanRochCoulon to see whether this is something that could be interesting to add (I would think this is a very useful feature). ", "Hello @JeanRochCoulon, it seems the ball is in your court for this issue.  If you decide to _not_ to support this feature, then please close this issue and create a task to clarify the behaviour in the User Manual.   Otherwise, and maybe this is better, you could decide to support this feature and so change the label from `Type:Enhancement` to `Type:Bug`.", "Indeed @MikeOpenHWGroup It is interesting to support this feature. WANTED VOLUNTEER !! I changed this Issue as Type:bug.", "@ASintzoff   As the topic is related to TRAPs you are verifying, I assign you the issue. Before fixing it in RTL, the first goal is to well describe what CVA6 does in specification."], "type": "hardware", "design": "default_riscv"}
{"index": 139, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/814", "title": "CVA6 hangs on store sequence", "body": "I have a CVA6 hang that was discovered running random tests cases in an emulation environment.\r\nI am in email contact with Florian, and will send him simulation waveforms of the hang.  Here is\r\na brief description of the failing sequence as seen in Spike and the CVA6 instruction trace.  The CVA6\r\nstops printing instruction data on a store byte.  In the sequence shown below, the spike model issues a couple\r\nof store bytes, a missed branch, a taken branch to a load, and a page fault taken on that load.  The \r\nCVA6 trace stops following the first store byte.  I'm not sure if this is the last instruction retired from the\r\nCVA6 or if the trace dump stopped earlier than the actual hang.  The AXI bus interface shows no unusual \r\nactivity.  There are no errors and all requests have been responded to.  The code and trace information is\r\nas follows:\r\n\r\nCode sequence:\r\n```\r\n0000000080000090 <interrupt_handlers>:\r\n    80000090:\t34102a73          \tcsrr\ts4,mepc\r\n\r\n00000000800009ba <loop_33>:\r\n    800009ba:\tfca6c003          \tlbu\tzero,-54(a3)\r\n    800009be:\t005686a3          \tsb\tt0,13(a3)\r\n    800009c2:\t0fe0e593          \tori\ta1,ra,254\r\n    800009c6:\t117d                \taddi\tsp,sp,-1\r\n    800009c8:\t02b206bb          \tmulw\ta3,tp,a1\r\n    800009cc:\t28257493          \tandi\ts1,a0,642\r\n    800009d0:\t418d                \tli\tgp,3\r\n    800009d2:\t02e48ca3          \tsb\ta4,57(s1)\r\n    800009d6:\te2368493          \taddi\ts1,a3,-477\r\n    800009da:\t47060213          \taddi\ttp,a2,1136\r\n\r\n00000000800009de <loop_34>:\r\n    800009de:\tfcc48b23          \tsb\ta2,-42(s1)\r\n    800009e2:\t02d606b3          \tmul\ta3,a2,a3\r\n    800009e6:\t02558ba3          \tsb\tt0,55(a1)\r\n    800009ea:\t11fd                \taddi\tgp,gp,-1\r\n    800009ec:\tfdc5c303          \tlbu\tt1,-36(a1)\r\n    800009f0:\tfe948ea3          \tsb\ts1,-3(s1)\r\n    800009f4:\t000489a3          \tsb\tzero,19(s1)\r\n    800009f8:\tfe0193e3          \tbnez\tgp,800009de <loop_34>\r\n    800009fc:\tfa011fe3          \tbnez\tsp,800009ba <loop_33>\r\n```\r\n\r\nSpike trace:\r\n```\r\n   core   0: 1 0x00000000800009e2 (0x02d606b3) x13 0x33dbb07401000000\r\n   core   0: 1 0x00000000800009e6 (0x02558ba3) mem 0x0000000080060077 0xed\r\n   core   0: 1 0x00000000800009ea (0x11fd) x 3 0x0000000000000000\r\n   core   0: 1 0x00000000800009ec (0xfdc5c303) x 6 0x000000000000003d mem 0x000000008006001c\r\n   core   0: 1 0x00000000800009f0 (0xfe948ea3) mem 0x000000008007fe60 0x63\r\n   core   0: 1 0x00000000800009f4 (0x000489a3) mem 0x000000008007fe76 0x0\r\n   core   0: 1 0x00000000800009f8 (0xfe0193e3)\r\n   core   0: 1 0x00000000800009fc (0xfa011fe3)\r\n   core   0: 3 0x0000000080000090 (0x34102a73) x20 0x00000000800009ba\r\n```\r\nCVA6 trace:\r\n\r\n```\r\n  192785ns    19178 S 00000000800009e2 0 02d606b3 mul            a3, a2, a3            a3  :33dbb07401000000 a2  :0000000080070040 a3  :8708404160040000\r\n  192805ns    19180 S 00000000800009e6 0 02558ba3 sb             t0, 55(a1)            t0  :000000008007fbed a1  :0000000080060040 VA: 0000000080060077 PA: 00000080060077\r\n  192805ns    19180 S 00000000800009ea 0 000011fd c.addi         gp, gp, -1            gp  :0000000000000000 gp  :0000000000000001\r\n  192835ns    19183 S 00000000800009ec 0 fdc5c303 lbu            t1, -36(a1)           t1  :000000000000003d a1  :0000000080060040 VA: 000000008006001c PA: 0000008006001c\r\n  192955ns    19195 S 00000000800009f0 0 fe948ea3 sb             s1, -3(s1)            s1  :000000008007fe63 s1  :000000008007fe63 VA: 000000008007fe60 PA: 00000080060e60\r\n```\r\n", "comments": ["First of all sorry for the large delay. We had issues with the licenses so that needed to be resolved first.\r\n\r\nIndeed I can confirm that there seems to be an issue with the LSU, interesting to see such a thing appearing now, I honestly wouldn't have expected it. It seems the the load unit violates the protocol to the cache unit when in the `WAIT_GNT` state and an exception is incoming (it doesn't properly kill the transaction to the cache) which then blocks the store unit from making forward progress, hence the lock-up.\r\n\r\nI am not 100% sure about the solution. But what I would essentially add is the case to properly terminate the transaction on:\r\nhttps://github.com/openhwgroup/cva6/blob/e4b48a794b0229eeb9264a6b3f459c86545d1d85/core/load_unit.sv#L247\r\n\r\n```verilog\r\nif (state_d != ABORT_TRANSACTION_NI || state_d != ABORT_TRANSACTION) state_d = Idle;\r\n```", "Hi @zarubaf and @JeanRochCoulon, it seems this is a valid RTL bug with a known solution.  However, the RTL has not be updated on either the `master` or `cv32a6_v5.0.0` branches.", "Hello @mpdickman, I know that the delay is large since you have discovered this issue. But, if we release a fixed version of CVA6, would you be able to check the fix by running your use case ?", "Closing because of staleness."], "type": "hardware", "design": "default_riscv"}
{"index": 140, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/790", "title": "Trap Handling: PC set to Other Adress than Specified by MTVEC", "body": "Hi,\r\n\r\nwe are formally verifying the processors behavior upon privilege increase. Therefore we are checking if a user-level process sets the PC to the correct address when a trap to machine or supervisor mode is executed.\r\n\r\nAccording to the RISCV-ISA (Document Version 20211203) section 3.1.7 (page 29) and 4.1.2 (page 66) the *mtvec* and *stvec* registers specify  how the corresponding address is calculated. Both registers consist of a BASE-field and a MODE-field. The MODE for *mtvec* and *stvec* can be set independently from each other to either *direct* or *vectored*. That means upon a trap to machine mode \r\n- PC is set to BASE of *mtvec* if the MODE of *mtvec* is *direct* \r\n- PC is set to BASE + 4 * cause if MODE is *vectored* and it is an interrupt. \r\n\r\nSimilarly traps into supervisor mode are handled according to the settings of BASE and MODE in *stvec*.\r\n\r\nWhen formally verifying this behavior on CVA6 we get a counterexample showing a behavior that does not comply with the ISA: A user-level process executes an interrupt and sets the PC to BASE + 4 * cause. However, the MODE of *mtvec* is set to *direct*.\r\n\r\nThe reason for that can be found in lines 981-998 or more precisely in line 996 of the csr_regfile.sv: \r\nhttps://github.com/openhwgroup/cva6/blob/e748564dd880d68a9b0bde7e1a92c48c75823391/core/csr_regfile.sv#L981-L998\r\nWhenever **one** MODE, the MODE of *mtvec* or the MODE of *stvec*, is set to *vectored* and it is an interrupt, the address calculation for the PC is done in *vectored* mode. Is this a bug or am I missing something here?\r\n\r\nThanks and best regards,\r\nAnna", "comments": ["Really, really, nice catch! You are right, we should distinguish the case to where we are trapping and then derive the `trap_vector_base_o`. I've pushed a fix to #792, it would be really cool if you could see whether the CEX goes away.", "@alda-tuk Any chance you had time to test the patch?", "Thanks for the confirmation and the fix! I was busy the last week, sorry for the late reply. I just ran the experiments for the patched design and the issue is fixed. :)", "No problem and thank you for your work. ", "Fixed by #792, thanks again."], "type": "hardware", "design": "default_riscv"}
{"index": 141, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/752", "title": "Possible issue with ASID on CV32A6", "body": "There is probably an issue with the ASID signal in the SV32's MMU for the CV32A6.\r\n1) ASID's width is hard coded in [cva6_tlb_sv32.sv](https://github.com/openhwgroup/cva6/blob/master/core/mmu_sv32/cva6_tlb_sv32.sv) and does **not** use the ASID_WIDTH parameter (which is used by the input ASID signal though). It should probably be modified to use that parameter.\r\n```verilog\r\n    input  logic [ASID_WIDTH-1:0]   lu_asid_i,\r\n```\r\n```verilog\r\n // Sv32 defines two levels of page tables\r\n    struct packed {\r\n      logic [8:0]            asid; //9 bits wide\r\n      logic [9:0]            vpn1; //10 bits wide\r\n      logic [9:0]            vpn0; //10 bits wide\r\n      logic                  is_4M;\r\n      logic                  valid;\r\n    } [TLB_ENTRIES-1:0] tags_q, tags_n;\r\n```\r\n\r\n2) The ASID_WIDTH parameter in [ariane_pkg.sv](https://github.com/openhwgroup/cva6/blob/master/core/include/ariane_pkg.sv) is set to 1 instead of 9 as per the RISC-V specs. It should be changed to 9 for XLEN = 32.\r\n```verilog\r\n    localparam ASID_WIDTH    = (riscv::XLEN == 64) ? 16 : 1;\r\n```\r\nRISC-V specs :\r\n![image](https://user-images.githubusercontent.com/72743979/136197811-c0e33ff9-dd71-4b30-93dd-cd4c62a1e9ff.png)\r\n", "comments": ["@ASintzoff, @sjthales, this Issue is very old, but _looks_ like an RTL bug.  Please assign someone to investigate.", "As @sjthales (developer of Sv32 MMU) is far more competent than me on this topic, I let him tackling the issue. Thanks.", "@fatimasaleem, can 10xEngineers help with this possible MMU bug?", "Spec says _\"The number of ASID bits is unspecified and may be zero.\"_ so setting  ASID_WIDTH to 1 is not a bug IMHO. But yes the tag struct should use `ASID_WIDTH`.", "Fixed in mmu unified https://github.com/openhwgroup/cva6/pull/1851"], "type": "hardware", "design": "default_riscv"}
{"index": 142, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/720", "title": "Some illegal instructions are capable of being executed", "body": "Location:  cva6/src/decoder.sv (https://github.com/openhwgroup/cva6/blob/master/src/decoder.sv), line 153 to 162.\r\n\r\nDetails: The if statement in the default case is missing else. Hence the illegal_instr will not be set even for instructions not meeting the if condition. \r\n\r\nThus any illegal instruction of the format 64\u2019hxxx00073 (\u2018x\u2019 is dont-care) will not be detected as illegal by Ariane. ", "comments": ["The input and log files that were forwarded by the team who discovered the issue.\r\n[bug_2.zip](https://github.com/openhwgroup/cva6/files/7114416/bug_2.zip)\r\n"], "type": "hardware", "design": "default_riscv"}
{"index": 143, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/719", "title": "Incorrect implementation of the FENCE.I instruction detection logic", "body": "Location:  cva6/src/decoder.sv (https://github.com/openhwgroup/cva6/blob/master/src/decoder.sv), line 220 to 240.\r\n\r\nDetails: The RISC-V specification states that the hardware implementations should ignore the imm, rs1, and rs2 fields of the FENCE.I instruction. However, the cv6 implementation expects a hardcoded value of zero in all these fields. Hence, it is flagging valid FENCE.I instructions with non-zero values in these fields as illegal instructions. \r\n\r\nFor example, the SPIKE successfully executes the FENCE.I instructions with non-zero imm field but cv6 does not. ", "comments": ["The inputs files and log files provided by the team who sent us the bug notice.\r\n[bug_1.zip](https://github.com/openhwgroup/cva6/files/7114409/bug_1.zip)\r\n"], "type": "hardware", "design": "default_riscv"}
{"index": 144, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/715", "title": "Update CSR MVENDORID to match OpenHW JEDEC Manufacturer ID", "body": "Current, `mvendorid` reads as 0x0.  I believe it should read as 0x0602 to match the vendor id of all other [CORE-V cores](https://cv32e40p.readthedocs.io/en/latest/control_status_registers/#machine-vendor-id-mvendorid).", "comments": [], "type": "hardware", "design": "default_riscv"}
{"index": 145, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/691", "title": "Potential deadlock in `cache_ctrl.sv`", "body": "### Discussed in https://github.com/openhwgroup/cva6/discussions/671\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **Simonlovald** May 28, 2021</sup>\r\nHello, \r\nI am currently working on my master thesis using the old cache_ctrl as a case study.\r\nMy topic is formal verification, and I am trying to automatize the generation of a complete set of properties for the design.\r\n\r\nWhile writing constraints for the design, I noticed some states that I am not really able to understand why they are needed.\r\nI can't see a scenario where there is no tag_valid-input and no gnt, coming from state IDLE, which then makes the cache_ctrl enter the WAIT_GNT? here: https://github.com/openhwgroup/cva6/blob/485662f0c9a315e084c5e18db49b4ea4a7503dfe/src/cache_subsystem/cache_ctrl.sv#L258-L268\r\nFrom my understanding both the load-unit and the ptw will always send a tag-valid in the next clock cycle after receiving data_gnt from the cache_ctrl. So how can the cache_ctrl possibly ever enter WAIT_GNT?\r\nOnly situation I can imagine, is if the load-unit got an exception when receiving the data_gnt, \r\nhttps://github.com/openhwgroup/cva6/blob/485662f0c9a315e084c5e18db49b4ea4a7503dfe/src/load_unit.sv#L244-L247\r\nbut then the load-cache_ctrl will be stuck in WAIT_GNT/WAIT_TAG, as there is no way the load-unit can receive another data_gnt while the cache_ctrl is waiting for a tag_valid and therefore will never issue a tag_valid... Sounds like a deadlock to me.\r\n\r\nI am guessing this is related to issue #430 \r\nI am grateful for any help regarding the understanding of this design.\r\nThank you in advance.</div>", "comments": ["Hi @zarubaf and @JeanRochCoulon.  This issue is very old and has not been looked at yet.  Ordinarily I would either close such an issue or forward it back to the originator (@Simonlovald) to close.  However, I stopped when I saw this:\r\n\r\n> Sounds like a deadlock to me.\r\n\r\nCan one or both of you look into this?"], "type": "hardware", "design": "default_riscv"}
{"index": 146, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/654", "title": "code point 0x120000f3 with rd=1 retires as sfence.vma", "body": "This is a collateral finding on the RTL from OneSpin processor app formal analysis.\r\nAccording to the RISC-V privileged ISA, only \"0001001 rs2 rs1 000 00000 1110011\" should decode as sfence.vma (Sail has the decoding as 0b0001001 @ rs2 @ rs1 @ 0b000 @ 0b00000 @ 0b1110011). However, cva6 seems to ignore the 5 bits of the RD fiels leading to, for example, 0x120000f3 being decoded as sfence.vma with rd=1 and actually retiring as no exception flag is set in the scoreboard and thus, it is flushed in conjunction with the instruction retired counter incrementing.\r\nExpected behavior would be to flag this as illegal.\r\n![sfence](https://user-images.githubusercontent.com/45827187/115229680-a0410b80-a113-11eb-8c30-d9009e5a667e.png)\r\nSee attached waveform - the problematic instruction word is fetched at -3, issued at -2, makes it to slot 0 of the scoreboard at -1, the scoreboard entry gets marked as valid at -1 and in this chycle, the scoreboard is flushed while the sfence commits and leads to the instruction retired counter being incremented from 0 to 1.\r\nNote that I cut the 8-bit counters in the cashes to get to a quick counterexample, but that should not be related to the reported issue which looks like a decoder issue. Git hash of examined RTL is 6000e32.", "comments": ["Hi @zarubaf and @JeanRochCoulon.  This is an old issue, but it comes from OneSpin (@tzwaenn) and I have come to greatly respect the work of this team.  I am willing to bet a couple of beer that this is a real bug.", "@AyoubJalali  As you can see, a bug has been found on SFENCE.VMA instruction. Is this instruction included in ISACOV ? What could be planned to cover it by the verification ? ", "@tzwaenn Hello, thanks for the issue, do you have the source file S or something to regenerate the bug", "@JeanRochCoulon No does not exist in the ISACOV", "Hi,\r\nI do not have my setup from 2 years ago anymore. I suggest trying instruction 0x120000f3 in the decoder. If it raises an illegal exception, the issue has been fixed in the meantime. If it gets decoded as sfence.vma, you have the problem reproduced.", "Fixed by commit b6c1d04b\r\nin PR https://github.com/openhwgroup/cva6/pull/933"], "type": "hardware", "design": "default_riscv"}
{"index": 147, "issue_url": "https://api.github.com/repos/openhwgroup/cva6/issues/606", "title": "MMU: INSTR_ACCESS_FAULT triggered by PMP", "body": "In mmu.sv, line 247, there's a mixture of vaddr and PLEN, which causes a misalignment in `tval`\r\n```icache_areq_o.fetch_exception = {riscv::INSTR_ACCESS_FAULT, {{riscv::XLEN-riscv::PLEN{1'b0}}, icache_areq_i.fetch_vaddr}, 1'b1};```\r\nSame for line 258\r\n```else icache_areq_o.fetch_exception = {riscv::INSTR_ACCESS_FAULT, {{riscv::XLEN-riscv::VLEN{1'b0}}, ptw_bad_paddr}, 1'b1};```", "comments": ["Hi @zarubaf and @JeanRochCoulon.  This is a report of a possible RTL bug that nobody has looked at.  The code snip-it above is still in the CVA6 code.  Please have a look.", "I think this was fixed or at least made consistent in #968 ", "Indeed, it is solved !   Thanks for the fix !  @masgia to my mind you can close the issue"], "type": "hardware", "design": "default_riscv"}
